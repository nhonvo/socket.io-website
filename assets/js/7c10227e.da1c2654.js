"use strict";(self.webpackChunksample_website=self.webpackChunksample_website||[]).push([[7370],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>h});var o=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},u="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),d=a,h=u["".concat(l,".").concat(d)]||u[d]||g[d]||r;return t?o.createElement(h,i(i({ref:n},c),{},{components:t})):o.createElement(h,i({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=t[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7519:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var o=t(8168),a=(t(6540),t(5680));const r={title:"Using multiple nodes",sidebar_position:5,slug:"/using-multiple-nodes/"},i=void 0,s={unversionedId:"categories/Server/using-multiple-nodes",id:"version-2.x/categories/Server/using-multiple-nodes",title:"Using multiple nodes",description:"Sticky load balancing",source:"@site/versioned_docs/version-2.x/categories/02-Server/using-multiple-nodes.md",sourceDirName:"categories/02-Server",slug:"/using-multiple-nodes/",permalink:"/docs/v2/using-multiple-nodes/",draft:!1,editUrl:"https://github.com/socketio/nhonvo.github.io/edit/main/versioned_docs/version-2.x/categories/02-Server/using-multiple-nodes.md",tags:[],version:"2.x",lastUpdatedAt:1631600541,formattedLastUpdatedAt:"Sep 14, 2021",sidebarPosition:5,frontMatter:{title:"Using multiple nodes",sidebar_position:5,slug:"/using-multiple-nodes/"},sidebar:"version-2.x/sidebar",previous:{title:"Namespaces",permalink:"/docs/v2/namespaces/"},next:{title:"Handling CORS",permalink:"/docs/v2/handling-cors/"}},l={},p=[{value:"Sticky load balancing",id:"sticky-load-balancing",level:2},{value:"NginX configuration",id:"nginx-configuration",level:2},{value:"Apache HTTPD configuration",id:"apache-httpd-configuration",level:2},{value:"HAProxy configuration",id:"haproxy-configuration",level:2},{value:"Using Node.JS Cluster",id:"using-nodejs-cluster",level:2},{value:"Passing events between nodes",id:"passing-events-between-nodes",level:2}],c={toc:p},u="wrapper";function g(e){let{components:n,...t}=e;return(0,a.yg)(u,(0,o.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h2",{id:"sticky-load-balancing"},"Sticky load balancing"),(0,a.yg)("p",null,"If you plan to distribute the load of connections among different processes or machines, you have to make sure that requests associated with a particular session id connect to the process that originated them."),(0,a.yg)("p",null,"This is due to certain transports like XHR Polling or JSONP Polling relying on firing several requests during the lifetime of the ","\u201c","socket","\u201d",". Failing to enable sticky balancing will result in the dreaded:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Error during WebSocket handshake: Unexpected response code: 400\n")),(0,a.yg)("p",null,"Which means that the upgrade request was sent to a node which did not know the given socket id, hence the HTTP 400 response."),(0,a.yg)("p",null,"To illustrate why this is needed, consider the example of emitting an event to all connected clients:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"io.emit('hi', 'all sockets');\n")),(0,a.yg)("p",null,"Chances are that some of those clients might have an active bi-directional communication channel like ",(0,a.yg)("inlineCode",{parentName:"p"},"WebSocket")," that we can write to immediately, but some of them might be using long-polling."),(0,a.yg)("p",null,"If they","\u2019","re using long polling, they might or might not have sent a request that we can write to. They could be ","\u201c","in between","\u201d"," those requests. In those situations, it means we have to buffer messages in the process. In order for the client to successfully claim those messages when he sends his request, the easiest way is for him to connect to be routed to that same process."),(0,a.yg)("p",null,"As noted above, ",(0,a.yg)("inlineCode",{parentName:"p"},"WebSocket")," transport do not have this limitation, since the underlying TCP connection is kept open between the client and the given server. That's why you might find some suggestions to only use the ",(0,a.yg)("inlineCode",{parentName:"p"},"WebSocket")," transport:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"const socket = io('https://io.yourhost.com', {\n  // WARNING: in that case, there is no fallback to long-polling\n  transports: [ 'websocket' ] // or [ 'websocket', 'polling' ], which is the same thing\n})\n")),(0,a.yg)("p",null,"Both means that there is ",(0,a.yg)("strong",{parentName:"p"},"NO FALLBACK")," to long-polling when the websocket connection cannot be established, which is in fact one of the key feature of Socket.IO. In that case, you should maybe consider using raw ",(0,a.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket"},"WebSocket"),", or a thin wrapper like ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/appuri/robust-websocket"},"robust-websocket"),"."),(0,a.yg)("p",null,"To achieve sticky-session, there are two main solutions:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"routing clients based on their originating address")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"routing clients based on a cookie"))),(0,a.yg)("h2",{id:"nginx-configuration"},"NginX configuration"),(0,a.yg)("p",null,"Within the ",(0,a.yg)("inlineCode",{parentName:"p"},"http { }")," section of your ",(0,a.yg)("inlineCode",{parentName:"p"},"nginx.conf")," file, you can declare a ",(0,a.yg)("inlineCode",{parentName:"p"},"upstream")," section with a list of Socket.IO process you want to balance load between:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-nginx"},'http {\n  server {\n    listen 3000;\n    server_name io.yourhost.com;\n\n    location / {\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      proxy_set_header Host $host;\n\n      proxy_pass http://nodes;\n\n      # enable WebSockets\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection "upgrade";\n    }\n  }\n\n  upstream nodes {\n    # enable sticky session based on IP\n    ip_hash;\n\n    server app01:3000;\n    server app02:3000;\n    server app03:3000;\n  }\n}\n')),(0,a.yg)("p",null,"Notice the ",(0,a.yg)("inlineCode",{parentName:"p"},"ip_hash")," instruction that indicates the connections will be sticky."),(0,a.yg)("p",null,"Make sure you also configure ",(0,a.yg)("inlineCode",{parentName:"p"},"worker_processes")," in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the ",(0,a.yg)("inlineCode",{parentName:"p"},"worker_connections")," setting within the ",(0,a.yg)("inlineCode",{parentName:"p"},"events { }")," block."),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://github.com/socketio/socket.io/tree/master/examples/cluster-nginx"},"Example")),(0,a.yg)("h2",{id:"apache-httpd-configuration"},"Apache HTTPD configuration"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-apache"},'Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED\n\n<Proxy "balancer://nodes_polling">\n    BalancerMember "http://app01:3000" route=app01\n    BalancerMember "http://app02:3000" route=app02\n    BalancerMember "http://app03:3000" route=app03\n    ProxySet stickysession=SERVERID\n</Proxy>\n\n<Proxy "balancer://nodes_ws">\n    BalancerMember "ws://app01:3000" route=app01\n    BalancerMember "ws://app02:3000" route=app02\n    BalancerMember "ws://app03:3000" route=app03\n    ProxySet stickysession=SERVERID\n</Proxy>\n\nRewriteEngine On\nRewriteCond %{HTTP:Upgrade} =websocket [NC]\nRewriteRule /(.*) balancer://nodes_ws/$1 [P,L]\nRewriteCond %{HTTP:Upgrade} !=websocket [NC]\nRewriteRule /(.*) balancer://nodes_polling/$1 [P,L]\n\nProxyTimeout 3\n')),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://github.com/socketio/socket.io/tree/master/examples/cluster-httpd"},"Example")),(0,a.yg)("h2",{id:"haproxy-configuration"},"HAProxy configuration"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/\n\nlisten chat\n  bind *:80\n  default_backend nodes\n\nbackend nodes\n  option httpchk HEAD /health\n  http-check expect status 200\n  cookie io prefix indirect nocache # using the `io` cookie set upon handshake\n  server app01 app01:3000 check cookie app01\n  server app02 app02:3000 check cookie app02\n  server app03 app03:3000 check cookie app03\n")),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://github.com/socketio/socket.io/tree/master/examples/cluster-haproxy"},"Example")),(0,a.yg)("h2",{id:"using-nodejs-cluster"},"Using Node.JS Cluster"),(0,a.yg)("p",null,"Just like NginX, Node.JS comes with built-in clustering support through the ",(0,a.yg)("inlineCode",{parentName:"p"},"cluster")," module."),(0,a.yg)("p",null,"Fedor Indutny has created a module called ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/indutny/sticky-session"},"sticky session")," that ensures file descriptors (ie: connections) are routed based on the originating ",(0,a.yg)("inlineCode",{parentName:"p"},"remoteAddress")," (ie: IP). Please note that this might lead to unbalanced routing, depending on the hashing method."),(0,a.yg)("p",null,"You could also assign a different port to each worker of the cluster, based on the cluster worker ID, and balance the load with the configuration that you can find above."),(0,a.yg)("h2",{id:"passing-events-between-nodes"},"Passing events between nodes"),(0,a.yg)("p",null,"Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to everyone (or even everyone in a certain ",(0,a.yg)("a",{parentName:"p",href:"/docs/v2/rooms/"},"room"),") you","\u2019","ll need some way of passing messages between processes or computers."),(0,a.yg)("p",null,"The interface in charge of routing messages is what we call the ",(0,a.yg)("inlineCode",{parentName:"p"},"Adapter"),". You can implement your own on top of the ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/socketio/socket.io-adapter"},"socket.io-adapter")," (by inheriting from it) or you can use the one we provide on top of ",(0,a.yg)("a",{parentName:"p",href:"https://redis.io/"},"Redis"),": ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/socketio/socket.io-redis"},"socket.io-redis"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"const io = require('socket.io')(3000);\nconst redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));\n")),(0,a.yg)("p",null,"Then the following call:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"io.emit('hi', 'all sockets');\n")),(0,a.yg)("p",null,"will be broadcast to every node through the ",(0,a.yg)("a",{parentName:"p",href:"https://redis.io/topics/pubsub"},"Pub/Sub mechanism")," of Redis."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Note:")," sticky-session is still needed when using the Redis adapter."),(0,a.yg)("p",null,"If you want to pass messages to it from non-socket.io processes, you should look into ",(0,a.yg)("a",{parentName:"p",href:"/docs/v2/rooms/#Sending-messages-from-the-outside-world"},"\u201c","Sending messages from the outside-world","\u201d"),"."))}g.isMDXComponent=!0}}]);