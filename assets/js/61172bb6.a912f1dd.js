"use strict";(self.webpackChunksample_website=self.webpackChunksample_website||[]).push([[5296],{5680:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>m});var o=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),g=c(t),u=a,m=g["".concat(l,".").concat(u)]||g[u]||p[u]||r;return t?o.createElement(m,i(i({ref:n},d),{},{components:t})):o.createElement(m,i({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[g]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3133:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=t(8168),a=(t(6540),t(5680));const r={title:"Migrating from 0.9",sidebar_position:1,slug:"/migrating-from-0-9/"},i=void 0,s={unversionedId:"categories/Migrations/migrating-from-0-9",id:"version-2.x/categories/Migrations/migrating-from-0-9",title:"Migrating from 0.9",description:"For most applications, the transition to 1.0 should be completely seamless and devoid of any hiccups. That said, we\u2019ve done some work to streamline some APIs, and we have changed some internals, so this is a recommended read for most existing users.",source:"@site/versioned_docs/version-2.x/categories/05-Migrations/migrating-from-0-9.md",sourceDirName:"categories/05-Migrations",slug:"/migrating-from-0-9/",permalink:"/docs/v2/migrating-from-0-9/",draft:!1,editUrl:"https://github.com/socketio/nhonvo.github.io/edit/main/versioned_docs/version-2.x/categories/05-Migrations/migrating-from-0-9.md",tags:[],version:"2.x",lastUpdatedAt:1631601618,formattedLastUpdatedAt:"Sep 14, 2021",sidebarPosition:1,frontMatter:{title:"Migrating from 0.9",sidebar_position:1,slug:"/migrating-from-0-9/"},sidebar:"version-2.x/sidebar",previous:{title:"Internals overview",permalink:"/docs/v2/internals/"},next:{title:"FAQ",permalink:"/docs/v2/faq/"}},l={},c=[{value:"Authentication differences",id:"authentication-differences",level:2},{value:"Socket.io uses middleware now",id:"socketio-uses-middleware-now",level:3},{value:"\u2026 so its cleaner to do auth via middleware now",id:"-so-its-cleaner-to-do-auth-via-middleware-now",level:3},{value:"Namespace authorization?",id:"namespace-authorization",level:3},{value:"Log differences",id:"log-differences",level:2},{value:"Logging is now based on debug",id:"logging-is-now-based-on-debug",level:3},{value:"Shortcuts",id:"shortcuts",level:2},{value:"Broadcasting to all clients in default namespace",id:"broadcasting-to-all-clients-in-default-namespace",level:3},{value:"Starting the server",id:"starting-the-server",level:3},{value:"Configuration differences",id:"configuration-differences",level:2},{value:"io.set is gone",id:"ioset-is-gone",level:3},{value:"Setting resource path",id:"setting-resource-path",level:3},{value:"Parser / Protocol differences",id:"parser--protocol-differences",level:2},{value:"Difference 1 \u2013 packet encoding",id:"difference-1--packet-encoding",level:3},{value:"Difference 2 \u2013 packet decoding",id:"difference-2--packet-decoding",level:3}],d={toc:c},g="wrapper";function p(e){let{components:n,...t}=e;return(0,a.yg)(g,(0,o.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"For most applications, the transition to 1.0 should be completely seamless and devoid of any hiccups. That said, we\u2019ve done some work to streamline some APIs, and we have changed some internals, so this is a recommended read for most existing users."),(0,a.yg)("h2",{id:"authentication-differences"},"Authentication differences"),(0,a.yg)("h3",{id:"socketio-uses-middleware-now"},"Socket.io uses middleware now"),(0,a.yg)("p",null,"You can give a Socket.io server arbitrary functions via ",(0,a.yg)("inlineCode",{parentName:"p"},"io.use()")," that are run when a socket is created. Check out this example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var srv = require('http').createServer();\nvar io = require('socket.io')(srv);\nvar run = 0;\nio.use(function(socket, next){\n  run++; // 0 -> 1\n  next();\n});\nio.use(function(socket, next) {\n  run++; // 1 -> 2\n  next();\n});\nvar socket = require('socket.io-client')();\nsocket.on('connect', function(){\n  // run == 2 at this time\n});\n")),(0,a.yg)("h3",{id:"-so-its-cleaner-to-do-auth-via-middleware-now"},"\u2026 so its cleaner to do auth via middleware now"),(0,a.yg)("p",null,"The old ",(0,a.yg)("inlineCode",{parentName:"p"},"io.set()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"io.get()")," methods are deprecated and only supported for backwards compatibility. Here is a translation of an old authorization example into middleware-style."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"io.set('authorization', function (handshakeData, callback) {\n  // make sure the handshake data looks good\n  callback(null, true); // error first, 'authorized' boolean second \n});\n")),(0,a.yg)("p",null,"vs."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"io.use(function(socket, next) {\n  var handshakeData = socket.request;\n  // make sure the handshake data looks good as before\n  // if error do this:\n    // next(new Error('not authorized'));\n  // else just call next\n  next();\n});\n")),(0,a.yg)("h3",{id:"namespace-authorization"},"Namespace authorization?"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"io.of('/namespace').use(function(socket, next) {\n  var handshakeData = socket.request;\n  next();\n});\n")),(0,a.yg)("h2",{id:"log-differences"},"Log differences"),(0,a.yg)("h3",{id:"logging-is-now-based-on-debug"},"Logging is now based on debug"),(0,a.yg)("p",null,"To print all debug logging, set the environment variable DEBUG to ",(0,a.yg)("em",{parentName:"p"},". ie: `DEBUG=")," node index.js`"),(0,a.yg)("p",null,"To print only socket.io related logging: ",(0,a.yg)("inlineCode",{parentName:"p"},"DEBUG=socket.io:* node index.js"),"."),(0,a.yg)("p",null,"To print logging only from the socket object: ",(0,a.yg)("inlineCode",{parentName:"p"},"DEBUG=socket.io:socket node index.js"),"."),(0,a.yg)("p",null,"This pattern should hopefully be making sense at this point. The names of the files in socket.io/lib are equivalent to their debug names."),(0,a.yg)("p",null,"Debug also works in the browser; logs are persisted to localstorage."),(0,a.yg)("p",null,"To use: open the developer console and type ",(0,a.yg)("inlineCode",{parentName:"p"},"localStorage.debug = 'socket.io:*'")," (or any debug level) and then refresh the page. Everything is logged until you run ",(0,a.yg)("inlineCode",{parentName:"p"},"localStorage.debug = ''")),(0,a.yg)("p",null,"See more at the debug documentation ",(0,a.yg)("a",{parentName:"p",href:"https://www.npmjs.org/package/debug"},"here"),"."),(0,a.yg)("h2",{id:"shortcuts"},"Shortcuts"),(0,a.yg)("p",null,"In general there are some new shortcuts for common things. The old versions should still work, but shortcuts are nice."),(0,a.yg)("h3",{id:"broadcasting-to-all-clients-in-default-namespace"},"Broadcasting to all clients in default namespace"),(0,a.yg)("p",null,"Previously:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"io.sockets.emit('eventname', 'eventdata');\n")),(0,a.yg)("p",null,"Now:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"io.emit('eventname', 'eventdata');\n")),(0,a.yg)("p",null,"Neat. Note that in both cases, these messages reach all clients connected to the default \u2018/\u2019 namespace, but not clients in other namespaces."),(0,a.yg)("h3",{id:"starting-the-server"},"Starting the server"),(0,a.yg)("p",null,"Previously:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var io = require('socket.io');\nvar socket = io.listen(80, { /* options */ });\n")),(0,a.yg)("p",null,"Now:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var io = require('socket.io');\nvar socket = io({ /* options */ });\n")),(0,a.yg)("h2",{id:"configuration-differences"},"Configuration differences"),(0,a.yg)("h3",{id:"ioset-is-gone"},"io.set is gone"),(0,a.yg)("p",null,"Instead do configuration in server initialization like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var socket = require('socket.io')({\n  // options go here\n});\n")),(0,a.yg)("p",null,"Options like log-level are gone. ",(0,a.yg)("inlineCode",{parentName:"p"},"io.set('transports')"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"io.set('heartbeat interval')"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"io.set('heartbeat timeout'"),", and ",(0,a.yg)("inlineCode",{parentName:"p"},"io.set('resource')")," are still supported for backwards compatibility."),(0,a.yg)("h3",{id:"setting-resource-path"},"Setting resource path"),(0,a.yg)("p",null,"The previous ",(0,a.yg)("inlineCode",{parentName:"p"},"resource")," option is equivalent to the new ",(0,a.yg)("inlineCode",{parentName:"p"},"path")," option, but needs a ",(0,a.yg)("inlineCode",{parentName:"p"},"/")," in the beginning. For example, the following configuration:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var socket = io.connect('localhost:3000', {\n  'resource': 'path/to/socket.io';\n});\n")),(0,a.yg)("p",null,"becomes:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var socket = io.connect('localhost:3000', {\n  'path': '/path/to/socket.io';\n});\n")),(0,a.yg)("h2",{id:"parser--protocol-differences"},"Parser / Protocol differences"),(0,a.yg)("p",null,"This is only relevant for updating things like socket.io implementations in other languages, custom socket.io clients, etc."),(0,a.yg)("h3",{id:"difference-1--packet-encoding"},"Difference 1 \u2013 packet encoding"),(0,a.yg)("p",null,"Parsing is now class based and asynchronous. Instead of returning a single encoded string, encode calls callback with an array of encodings as the only argument. Each encoding should be written to the transport in order. This is more flexible and makes binary data transport work. Here\u2019s an example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var encoding = parser.encode(packet);\nconsole.log(encoding); // fully encoded packet`\n")),(0,a.yg)("p",null,"vs."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var encoder = new parser.Encoder();\nencoder.encode(packet, function(encodings) {\n  for (var i = 0; i &lt; encodings.length; i++) {\n    console.log(encodings[i]); // encoded parts of the packet\n  }\n});\n")),(0,a.yg)("h3",{id:"difference-2--packet-decoding"},"Difference 2 \u2013 packet decoding"),(0,a.yg)("p",null,"Decoding takes things a step further and is event-based. This is done because some objects (binary-containing) are both encoded and decoded in multiple parts. This example should help:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var packet = parser.decode(decoding);\nconsole.log(packet); // formed socket.io packet to handle\n")),(0,a.yg)("p",null,"vs."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"var decoder = new parser.Decoder();\ndecoder.on('decoded', function(packet) {\n  console.log(packet); // formed socket.io packet to handle\n});\ndecoder.add(encodings[0]); // say encodings is array of two encodings received from transport\ndecoder.add(encodings[1]); // after adding the last element, 'decoded' is emitted from decoder\n")))}p.isMDXComponent=!0}}]);