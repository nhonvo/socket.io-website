"use strict";(self.webpackChunksample_website=self.webpackChunksample_website||[]).push([[8113],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>u});var r=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),g=a,u=d["".concat(c,".").concat(g)]||d[g]||y[g]||o;return n?r.createElement(u,i(i({ref:t},p),{},{components:n})):r.createElement(u,i({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=g;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},8020:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>y,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(8168),a=(n(6540),n(5680));const o={title:"Connection state recovery",sidebar_position:4,slug:"/connection-state-recovery"},i=void 0,s={unversionedId:"categories/Documentation/connection-state-recovery",id:"categories/Documentation/connection-state-recovery",title:"Connection state recovery",description:"Connection state recovery is a feature which allows restoring a client's state after a temporary disconnection, including any missed packets.",source:"@site/docs/categories/01-Documentation/connection-state-recovery.md",sourceDirName:"categories/01-Documentation",slug:"/connection-state-recovery",permalink:"/docs/v4/connection-state-recovery",draft:!1,editUrl:"https://github.com/socketio/nhonvo.github.io/edit/main/docs/categories/01-Documentation/connection-state-recovery.md",tags:[],version:"current",lastUpdatedAt:1695207933,formattedLastUpdatedAt:"Sep 20, 2023",sidebarPosition:4,frontMatter:{title:"Connection state recovery",sidebar_position:4,slug:"/connection-state-recovery"},sidebar:"sidebar",previous:{title:"Delivery guarantees",permalink:"/docs/v4/delivery-guarantees"},next:{title:"Logging and debugging",permalink:"/docs/v4/logging-and-debugging/"}},c={},l=[{value:"Disclaimer",id:"disclaimer",level:2},{value:"Usage",id:"usage",level:2},{value:"Compatibility with existing adapters",id:"compatibility-with-existing-adapters",level:2},{value:"How it works under the hood",id:"how-it-works-under-the-hood",level:2}],p={toc:l},d="wrapper";function y(e){let{components:t,...n}=e;return(0,a.yg)(d,(0,r.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"Connection state recovery is a feature which allows restoring a client's state after a temporary disconnection, including any missed packets."),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"This feature was added in version ",(0,a.yg)("inlineCode",{parentName:"p"},"4.6.0"),", released in February 2023."),(0,a.yg)("p",{parentName:"admonition"},"The release notes can be found ",(0,a.yg)("a",{parentName:"p",href:"/docs/v4/changelog/4.6.0"},"here"),".")),(0,a.yg)("h2",{id:"disclaimer"},"Disclaimer"),(0,a.yg)("p",null,"Under real conditions, a Socket.IO client will inevitably experience temporary disconnections, regardless of the quality of the connection."),(0,a.yg)("p",null,"This feature will help you cope with such disconnections, but unless you want to store the packets and the sessions forever (by setting ",(0,a.yg)("inlineCode",{parentName:"p"},"maxDisconnectionDuration")," to ",(0,a.yg)("inlineCode",{parentName:"p"},"Infinity"),"), you can't be assured that the recovery will always be successful."),(0,a.yg)("p",null,"That's why you will still need to handle the case where the states of the client and the server must be synchronized."),(0,a.yg)("h2",{id:"usage"},"Usage"),(0,a.yg)("p",null,"Connection state recovery must be enabled by the server:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"const io = new Server(httpServer, {\n  connectionStateRecovery: {\n    // the backup duration of the sessions and the packets\n    maxDisconnectionDuration: 2 * 60 * 1000,\n    // whether to skip middlewares upon successful recovery\n    skipMiddlewares: true,\n  }\n});\n")),(0,a.yg)("p",null,"Upon an unexpected disconnection (i.e. no manual disconnection with ",(0,a.yg)("inlineCode",{parentName:"p"},"socket.disconnect()"),"), the server will store the ",(0,a.yg)("inlineCode",{parentName:"p"},"id"),", the rooms and the ",(0,a.yg)("inlineCode",{parentName:"p"},"data")," attribute of the socket."),(0,a.yg)("p",null,"Then upon reconnection, the server will try to restore the state of the client. The ",(0,a.yg)("inlineCode",{parentName:"p"},"recovered")," attribute indicates whether this recovery was successful:"),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"Server")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},'io.on("connection", (socket) => {\n  if (socket.recovered) {\n    // recovery was successful: socket.id, socket.rooms and socket.data were restored\n  } else {\n    // new or unrecoverable session\n  }\n});\n')),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"Client")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},'socket.on("connect", () => {\n  if (socket.recovered) {\n    // any event missed during the disconnection period will be received now\n  } else {\n    // new or unrecoverable session\n  }\n});\n')),(0,a.yg)("p",null,"You can check that the recovery is working by forcefully closing the underlying engine:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},'import { io } from "socket.io-client";\n\nconst socket = io({\n  reconnectionDelay: 10000, // defaults to 1000\n  reconnectionDelayMax: 10000 // defaults to 5000\n});\n\nsocket.on("connect", () => {\n  console.log("recovered?", socket.recovered);\n\n  setTimeout(() => {\n    if (socket.io.engine) {\n      // close the low-level connection and trigger a reconnection\n      socket.io.engine.close();\n    }\n  }, 10000);\n});\n')),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"You can also run this example directly in your browser on:"),(0,a.yg)("ul",{parentName:"admonition"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"https://codesandbox.io/p/sandbox/github/socketio/socket.io/tree/main/examples/connection-state-recovery-example/esm?file=index.js"},"CodeSandbox")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"https://stackblitz.com/github/socketio/socket.io/tree/main/examples/connection-state-recovery-example/esm?file=index.js"},"StackBlitz")))),(0,a.yg)("h2",{id:"compatibility-with-existing-adapters"},"Compatibility with existing adapters"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Adapter"),(0,a.yg)("th",{parentName:"tr",align:"center"},"Support?"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Built-in adapter (in memory)"),(0,a.yg)("td",{parentName:"tr",align:"center"},"YES \u2705")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"/docs/v4/redis-adapter/"},"Redis adapter")),(0,a.yg)("td",{parentName:"tr",align:"center"},"NO",(0,a.yg)("sup",null,"1"))),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"/docs/v4/redis-streams-adapter/"},"Redis Streams adapter")),(0,a.yg)("td",{parentName:"tr",align:"center"},"YES \u2705")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"/docs/v4/mongo-adapter/"},"MongoDB adapter")),(0,a.yg)("td",{parentName:"tr",align:"center"},"YES \u2705 (since version ",(0,a.yg)("a",{parentName:"td",href:"https://github.com/socketio/socket.io-mongo-adapter/releases/tag/0.3.0"},(0,a.yg)("inlineCode",{parentName:"a"},"0.3.0")),")")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"/docs/v4/postgres-adapter/"},"Postgres adapter")),(0,a.yg)("td",{parentName:"tr",align:"center"},"WIP")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"/docs/v4/cluster-adapter/"},"Cluster adapter")),(0,a.yg)("td",{parentName:"tr",align:"center"},"WIP")))),(0,a.yg)("p",null,"[1]"," Persisting the packets is not compatible with the Redis PUB/SUB mechanism."),(0,a.yg)("h2",{id:"how-it-works-under-the-hood"},"How it works under the hood"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"the server sends a session ID ",(0,a.yg)("a",{parentName:"li",href:"/docs/v4/socket-io-protocol/#connection-to-a-namespace-1"},"during the handshake")," (which is different from the current id attribute, which is public and can be freely shared)")),(0,a.yg)("p",null,"Example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'40{"sid":"GNpWD7LbGCBNCr8GAAAB","pid":"YHcX2sdAF1z452-HAAAW"}\n\nwhere\n\n4         => the Engine.IO message type\n0         => the Socket.IO CONNECT type\nGN...AB   => the public id of the session\nYH...AW   => the private id of the session\n')),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"the server also includes an offset in ",(0,a.yg)("a",{parentName:"li",href:"/docs/v4/socket-io-protocol/#sending-and-receiving-data-1"},"each packet")," (added at the end of the data array, for backward compatibility)")),(0,a.yg)("p",null,"Example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'42["foo","MzUPkW0"]\n\nwhere\n\n4         => the Engine.IO message type\n2         => the Socket.IO EVENT type\nfoo       => the event name (socket.emit("foo"))\nMzUPkW0   => the offset\n')),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"For the recovery to succeed, the server must send at least one event, in order to initialize the offset on the client side.")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"upon temporary disconnection, the server stores the client state for a given delay (implemented at the adapter level)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"upon reconnection, the client sends both the session ID and the last offset it has processed, and the server tries to restore the state"))),(0,a.yg)("p",null,"Example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'40{"pid":"YHcX2sdAF1z452-HAAAW","offset":"MzUPkW0"}\n\nwhere\n\n4         => the Engine.IO message type\n0         => the Socket.IO CONNECT type\nYH...AW   => the private id of the session\nMzUPkW0   => the last processed offset\n')))}y.isMDXComponent=!0}}]);