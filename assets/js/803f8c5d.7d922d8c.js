"use strict";(self.webpackChunksample_website=self.webpackChunksample_website||[]).push([[1788],{5680:(e,n,a)=>{a.d(n,{xA:()=>c,yg:()=>y});var t=a(6540);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},c=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),g=p(a),d=r,y=g["".concat(s,".").concat(d)]||g[d]||u[d]||o;return a?t.createElement(y,l(l({ref:n},c),{},{components:a})):t.createElement(y,l({ref:n},c))}));function y(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=d;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[g]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=a[p];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}d.displayName="MDXCreateElement"},7578:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var t=a(8168),r=(a(6540),a(5680));const o={layout:"post",title:"Clean Code concepts adapted for .NET/.NET Core",subtitle:"",date:new Date("2023-01-09T12:00:00.000Z"),author:"Truong Nhon",hidden:!1,published:!0,multilingual:!1,catalog:!0,lang:"en",tags:["c#"]},l=void 0,i={permalink:"/2024/1/9/Clean-code",editUrl:"https://github.com/nhonvo/nhonvo.github.io/edit/main/blog/blog/2024-1-9-Clean-code.md",source:"@site/blog/2024-1-9-Clean-code.md",title:"Clean Code concepts adapted for .NET/.NET Core",description:"Naming",date:"2023-01-09T12:00:00.000Z",formattedDate:"January 9, 2023",tags:[{label:"c#",permalink:"/tags/c"}],readingTime:42.515,hasTruncateMarker:!1,authors:[{name:"Truong Nhon"}],frontMatter:{layout:"post",title:"Clean Code concepts adapted for .NET/.NET Core",subtitle:"",date:"2023-01-09T12:00:00.000Z",author:"Truong Nhon",hidden:!1,published:!0,multilingual:!1,catalog:!0,lang:"en",tags:["c#"]},prevItem:{title:"Fundamentals-SQL",permalink:"/2023/12/25/Fundamentals-SQL"}},s={authorsImageUrls:[void 0]},p=[{value:"Naming",id:"naming",level:2},{value:"Variables",id:"variables",level:2},{value:"Functions",id:"functions",level:2},{value:"Objects and Data Structures",id:"objects-and-data-structures",level:2},{value:"Classes",id:"classes",level:2},{value:"SOLID",id:"solid",level:2},{value:"Testing",id:"testing",level:2},{value:"Concurrency",id:"concurrency",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Formatting",id:"formatting",level:2},{value:"Comments",id:"comments",level:2}],c={toc:p},g="wrapper";function u(e){let{components:n,...a}=e;return(0,r.yg)(g,(0,t.A)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"naming"},"Naming"),(0,r.yg)("b",null,"Avoid using bad names"),(0,r.yg)("p",null,"A good name allows the code to be used by many developers. The name should reflect what it does and give context."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"int d;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"int daySinceModification;\n")),(0,r.yg)("b",null,"Avoid Misleading Names"),(0,r.yg)("p",null,"Name the variable to reflect what it is used for."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var dataFromDb = db.GetFromService().ToList();\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var listOfEmployee = _employeeService.GetEmployees().ToList();\n")),(0,r.yg)("b",null,"Avoid Hungarian notation"),(0,r.yg)("p",null,"Hungarian Notation restates the type which is already present in the declaration. This is pointless since modern IDEs will identify the type."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"int iCounter;\nstring strFullName;\nDateTime dModifiedDate;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"int counter;\nstring fullName;\nDateTime modifiedDate;\n")),(0,r.yg)("p",null,"Hungarian Notation should also not be used in paramaters."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public bool IsShopOpen(string pDay, int pAmount)\n{\n    // some logic\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public bool IsShopOpen(string day, int amount)\n{\n    // some logic\n}\n")),(0,r.yg)("b",null,"Use consistent capitalization"),(0,r.yg)("p",null,"Capitalization tells you a lot about your variables,\nfunctions, etc. These rules are subjective, so your team can choose whatever\nthey want. The point is, no matter what you all choose, just be consistent."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"const int DAYS_IN_WEEK = 7;\nconst int daysInMonth = 30;\n\nvar songs = new List<string> { 'Back In Black', 'Stairway to Heaven', 'Hey Jude' };\nvar Artists = new List<string> { 'ACDC', 'Led Zeppelin', 'The Beatles' };\n\nbool EraseDatabase() {}\nbool Restore_database() {}\n\nclass animal {}\nclass Alpaca {}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"const int DaysInWeek = 7;\nconst int DaysInMonth = 30;\n\nvar songs = new List<string> { 'Back In Black', 'Stairway to Heaven', 'Hey Jude' };\nvar artists = new List<string> { 'ACDC', 'Led Zeppelin', 'The Beatles' };\n\nbool EraseDatabase() {}\nbool RestoreDatabase() {}\n\nclass Animal {}\nclass Alpaca {}\n")),(0,r.yg)("b",null,"Use pronounceable names"),(0,r.yg)("p",null,"It will take time to investigate the meaning of the variables and functions when they are not pronounceable."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Employee\n{\n    public Datetime sWorkDate { get; set; } // what the heck is this\n    public Datetime modTime { get; set; } // same here\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Employee\n{\n    public Datetime StartWorkingDate { get; set; }\n    public Datetime ModificationTime { get; set; }\n}\n")),(0,r.yg)("b",null,"Use Camelcase notation"),(0,r.yg)("p",null,"Use ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Camel_case"},"Camelcase Notation")," for variable and method paramaters."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var employeephone;\n\npublic double CalculateSalary(int workingdays, int workinghours)\n{\n    // some logic\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var employeePhone;\n\npublic double CalculateSalary(int workingDays, int workingHours)\n{\n    // some logic\n}\n")),(0,r.yg)("b",null,"Use domain name"),(0,r.yg)("p",null,"People who read your code are also programmers. Naming things right will help everyone be on the same page. We don't want to take time to explain to everyone what a variable or function is for."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public class SingleObject\n{\n    // create an object of SingleObject\n    private static SingleObject _instance = new SingleObject();\n\n    // make the constructor private so that this class cannot be instantiated\n    private SingleObject() {}\n\n    // get the only object available\n    public static SingleObject GetInstance()\n    {\n        return _instance;\n    }\n\n    public string ShowMessage()\n    {\n        return "Hello World!";\n    }\n}\n\npublic static void main(String[] args)\n{\n    // illegal construct\n    // var object = new SingleObject();\n\n    // Get the only object available\n    var singletonObject = SingleObject.GetInstance();\n\n    // show the message\n    singletonObject.ShowMessage();\n}\n')),(0,r.yg)("h2",{id:"variables"},"Variables"),(0,r.yg)("b",null,"Avoid nesting too deeply and return early"),(0,r.yg)("p",null,"Too many if else statements can make the code hard to follow. ",(0,r.yg)("strong",{parentName:"p"},"Explicit is better than implicit"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public bool IsShopOpen(string day)\n{\n    if (!string.IsNullOrEmpty(day))\n    {\n        day = day.ToLower();\n        if (day == "friday")\n        {\n            return true;\n        }\n        else if (day == "saturday")\n        {\n            return true;\n        }\n        else if (day == "sunday")\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    else\n    {\n        return false;\n    }\n\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public bool IsShopOpen(string day)\n{\n    if (string.IsNullOrEmpty(day))\n    {\n        return false;\n    }\n\n    var openingDays = new[] { "friday", "saturday", "sunday" };\n    return openingDays.Any(d => d == day.ToLower());\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public long Fibonacci(int n)\n{\n    if (n < 50)\n    {\n        if (n != 0)\n        {\n            if (n != 1)\n            {\n                return Fibonacci(n - 1) + Fibonacci(n - 2);\n            }\n            else\n            {\n                return 1;\n            }\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    else\n    {\n        throw new System.Exception("Not supported");\n    }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public long Fibonacci(int n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n\n    if (n == 1)\n    {\n        return 1;\n    }\n\n    if (n > 50)\n    {\n        throw new System.Exception("Not supported");\n    }\n\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n')),(0,r.yg)("b",null,"Avoid mental mapping"),(0,r.yg)("p",null,"Don\u2019t force the reader of your code to translate what the variable means. ",(0,r.yg)("strong",{parentName:"p"},"Explicit is better than implicit"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var l = new[] { "Austin", "New York", "San Francisco" };\n\nfor (var i = 0; i < l.Count(); i++)\n{\n    var li = l[i];\n    DoStuff();\n    DoSomeOtherStuff();\n\n    // ...\n    // ...\n    // ...\n    // Wait, what is `li` for again?\n    Dispatch(li);\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var locations = new[] { "Austin", "New York", "San Francisco" };\n\nforeach (var location in locations)\n{\n    DoStuff();\n    DoSomeOtherStuff();\n\n    // ...\n    // ...\n    // ...\n    Dispatch(location);\n}\n')),(0,r.yg)("b",null,"Avoid magic string"),(0,r.yg)("p",null,"Magic strings are string values that are specified directly within application code that have an impact on the application\u2019s behavior. Frequently, such strings will end up being duplicated within the system, and since they cannot automatically be updated using refactoring tools, they become a common source of bugs when changes are made to some strings but not others."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'if (userRole == "Admin")\n{\n    // logic in here\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'const string ADMIN_ROLE = "Admin"\nif (userRole == ADMIN_ROLE)\n{\n    // logic in here\n}\n')),(0,r.yg)("p",null,"Using this we only have to change in centralize place and others will adapt it."),(0,r.yg)("b",null,"Don't add unneeded context"),(0,r.yg)("p",null,"If your class/object name tells you something, don't repeat that in your variable name."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Car\n{\n    public string CarMake { get; set; }\n    public string CarModel { get; set; }\n    public string CarColor { get; set; }\n\n    //...\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Car\n{\n    public string Make { get; set; }\n    public string Model { get; set; }\n    public string Color { get; set; }\n\n    //...\n}\n")),(0,r.yg)("b",null,"Use meaningful and pronounceable variable names"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var ymdstr = DateTime.UtcNow.ToString("MMMM dd, yyyy");\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var currentDate = DateTime.UtcNow.ToString("MMMM dd, yyyy");\n')),(0,r.yg)("b",null,"Use the same vocabulary for the same type of variable"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"GetUserInfo();\nGetUserData();\nGetUserRecord();\nGetUserProfile();\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"GetUser();\n")),(0,r.yg)("b",null,"Use searchable names (part 1)"),(0,r.yg)("p",null,"We will read more code than we will ever write. It's important that the code we do write is readable and searchable. By ",(0,r.yg)("em",{parentName:"p"},"not")," naming variables that end up being meaningful for understanding our program, we hurt our readers. Make your names searchable."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'// What the heck is data for?\nvar data = new { Name = "John", Age = 42 };\n\nvar stream1 = new MemoryStream();\nvar ser1 = new DataContractJsonSerializer(typeof(object));\nser1.WriteObject(stream1, data);\n\nstream1.Position = 0;\nvar sr1 = new StreamReader(stream1);\nConsole.Write("JSON form of Data object: ");\nConsole.WriteLine(sr1.ReadToEnd());\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var person = new Person\n{\n    Name = "John",\n    Age = 42\n};\n\nvar stream2 = new MemoryStream();\nvar ser2 = new DataContractJsonSerializer(typeof(Person));\nser2.WriteObject(stream2, data);\n\nstream2.Position = 0;\nvar sr2 = new StreamReader(stream2);\nConsole.Write("JSON form of Data object: ");\nConsole.WriteLine(sr2.ReadToEnd());\n')),(0,r.yg)("b",null,"Use searchable names (part 2)"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var data = new { Name = "John", Age = 42, PersonAccess = 4};\n\n// What the heck is 4 for?\nif (data.PersonAccess == 4)\n{\n    // do edit ...\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public enum PersonAccess : int\n{\n    ACCESS_READ = 1,\n    ACCESS_CREATE = 2,\n    ACCESS_UPDATE = 4,\n    ACCESS_DELETE = 8\n}\n\nvar person = new Person\n{\n    Name = "John",\n    Age = 42,\n    PersonAccess= PersonAccess.ACCESS_CREATE\n};\n\nif (person.PersonAccess == PersonAccess.ACCESS_UPDATE)\n{\n    // do edit ...\n}\n')),(0,r.yg)("b",null,"Use explanatory variables"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'const string Address = "One Infinite Loop, Cupertino 95014";\nvar cityZipCodeRegex = @"/^[^,\\]+[,\\\\s]+(.+?)\\s*(\\d{5})?$/";\nvar matches = Regex.Matches(Address, cityZipCodeRegex);\nif (matches[0].Success == true && matches[1].Success == true)\n{\n    SaveCityZipCode(matches[0].Value, matches[1].Value);\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("p",null,"Decrease dependence on regex by naming subpatterns."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'const string Address = "One Infinite Loop, Cupertino 95014";\nvar cityZipCodeWithGroupRegex = @"/^[^,\\]+[,\\\\s]+(?<city>.+?)\\s*(?<zipCode>\\d{5})?$/";\nvar matchesWithGroup = Regex.Match(Address, cityZipCodeWithGroupRegex);\nvar cityGroup = matchesWithGroup.Groups["city"];\nvar zipCodeGroup = matchesWithGroup.Groups["zipCode"];\nif(cityGroup.Success == true && zipCodeGroup.Success == true)\n{\n    SaveCityZipCode(cityGroup.Value, zipCodeGroup.Value);\n}\n')),(0,r.yg)("b",null,"Use default arguments instead of short circuiting or conditionals"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Not good:")),(0,r.yg)("p",null,"This is not good because ",(0,r.yg)("inlineCode",{parentName:"p"},"breweryName")," can be ",(0,r.yg)("inlineCode",{parentName:"p"},"NULL"),"."),(0,r.yg)("p",null,"This opinion is more understandable than the previous version, but it better controls the value of the variable."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public void CreateMicrobrewery(string name = null)\n{\n    var breweryName = !string.IsNullOrEmpty(name) ? name : "Hipster Brew Co.";\n    // ...\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public void CreateMicrobrewery(string breweryName = "Hipster Brew Co.")\n{\n    // ...\n}\n')),(0,r.yg)("h2",{id:"functions"},"Functions"),(0,r.yg)("b",null,"Avoid side effects"),(0,r.yg)("p",null,"A function produces a side effect if it does anything other than take a value in and return another value or values. A side effect could be writing to a file, modifying some global variable, or accidentally wiring all your money to a stranger."),(0,r.yg)("p",null,"Now, you do need to have side effects in a program on occasion. Like the previous example, you might need to write to a file. What you want to do is to centralize where you are doing this. Don't have several functions and classes that write to a particular file. Have one service that does it. One and only one."),(0,r.yg)("p",null,"The main point is to avoid common pitfalls like sharing state between objects without any structure, using mutable data types that can be written to by anything, and not centralizing where your side effects occur. If you can do this, you will be happier\nthan the vast majority of other programmers."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'// Global variable referenced by following function.\n// If we had another function that used this name, now it\'d be an array and it could break it.\nvar name = "Ryan McDermott";\n\npublic void SplitAndEnrichFullName()\n{\n    var temp = name.Split(" ");\n    name = $"His first name is {temp[0]}, and his last name is {temp[1]}"; // side effect\n}\n\nSplitAndEnrichFullName();\n\nConsole.WriteLine(name); // His first name is Ryan, and his last name is McDermott\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public string SplitAndEnrichFullName(string name)\n{\n    var temp = name.Split(" ");\n    return $"His first name is {temp[0]}, and his last name is {temp[1]}";\n}\n\nvar name = "Ryan McDermott";\nvar fullName = SplitAndEnrichFullName(name);\n\nConsole.WriteLine(name); // Ryan McDermott\nConsole.WriteLine(fullName); // His first name is Ryan, and his last name is McDermott\n')),(0,r.yg)("b",null,"Avoid negative conditionals"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public bool IsDOMNodeNotPresent(string node)\n{\n    // ...\n}\n\nif (!IsDOMNodeNotPresent(node))\n{\n    // ...\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public bool IsDOMNodePresent(string node)\n{\n    // ...\n}\n\nif (IsDOMNodePresent(node))\n{\n    // ...\n}\n")),(0,r.yg)("b",null,"Avoid conditionals"),(0,r.yg)("p",null,'This seems like an impossible task. Upon first hearing this, most people say, "how am I supposed to do anything without an ',(0,r.yg)("inlineCode",{parentName:"p"},"if"),' statement?" The answer is that you can use polymorphism to achieve the same task in many cases. The second question is usually, "well that\'s great but why would I want to do that?" The answer is a previous clean code concept we learned: a function should only do\none thing. When you have classes and functions that have ',(0,r.yg)("inlineCode",{parentName:"p"},"if")," statements, you are telling your user that your function does more than one thing. Remember, just do one thing."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class Airplane\n{\n    // ...\n\n    public double GetCruisingAltitude()\n    {\n        switch (_type)\n        {\n            case '777':\n                return GetMaxAltitude() - GetPassengerCount();\n            case 'Air Force One':\n                return GetMaxAltitude();\n            case 'Cessna':\n                return GetMaxAltitude() - GetFuelExpenditure();\n        }\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"interface IAirplane\n{\n    // ...\n\n    double GetCruisingAltitude();\n}\n\nclass Boeing777 : IAirplane\n{\n    // ...\n\n    public double GetCruisingAltitude()\n    {\n        return GetMaxAltitude() - GetPassengerCount();\n    }\n}\n\nclass AirForceOne : IAirplane\n{\n    // ...\n\n    public double GetCruisingAltitude()\n    {\n        return GetMaxAltitude();\n    }\n}\n\nclass Cessna : IAirplane\n{\n    // ...\n\n    public double GetCruisingAltitude()\n    {\n        return GetMaxAltitude() - GetFuelExpenditure();\n    }\n}\n")),(0,r.yg)("b",null,"Avoid type-checking (part 1)"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public Path TravelToTexas(object vehicle)\n{\n    if (vehicle.GetType() == typeof(Bicycle))\n    {\n        (vehicle as Bicycle).PeddleTo(new Location("texas"));\n    }\n    else if (vehicle.GetType() == typeof(Car))\n    {\n        (vehicle as Car).DriveTo(new Location("texas"));\n    }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public Path TravelToTexas(Traveler vehicle)\n{\n    vehicle.TravelTo(new Location("texas"));\n}\n')),(0,r.yg)("p",null,"or"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'// pattern matching\npublic Path TravelToTexas(object vehicle)\n{\n    if (vehicle is Bicycle bicycle)\n    {\n        bicycle.PeddleTo(new Location("texas"));\n    }\n    else if (vehicle is Car car)\n    {\n        car.DriveTo(new Location("texas"));\n    }\n}\n')),(0,r.yg)("b",null,"Avoid type-checking (part 2)"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public int Combine(dynamic val1, dynamic val2)\n{\n    int value;\n    if (!int.TryParse(val1, out value) || !int.TryParse(val2, out value))\n    {\n        throw new Exception('Must be of type Number');\n    }\n\n    return val1 + val2;\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public int Combine(int val1, int val2)\n{\n    return val1 + val2;\n}\n")),(0,r.yg)("b",null,"Avoid flags in method parameters"),(0,r.yg)("p",null,"A flag indicates that the method has more than one responsibility. It is best if the method only has a single responsibility. Split the method into two if a boolean parameter adds multiple responsibilities to the method."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public void CreateFile(string name, bool temp = false)\n{\n    if (temp)\n    {\n        Touch("./temp/" + name);\n    }\n    else\n    {\n        Touch(name);\n    }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public void CreateFile(string name)\n{\n    Touch(name);\n}\n\npublic void CreateTempFile(string name)\n{\n    Touch("./temp/"  + name);\n}\n')),(0,r.yg)("b",null,"Don't write to global functions"),(0,r.yg)("p",null,"Polluting globals is a bad practice in many languages because you could clash with another library and the user of your API would be none-the-wiser until they get an exception in production. Let's think about an example: what if you wanted to have configuration array.\nYou could write global function like ",(0,r.yg)("inlineCode",{parentName:"p"},"Config()"),", but it could clash with another library that tried to do the same thing."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public Dictionary<string, string> Config()\n{\n    return new Dictionary<string,string>(){\n        ["foo"] = "bar"\n    };\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class Configuration\n{\n    private Dictionary<string, string> _configuration;\n\n    public Configuration(Dictionary<string, string> configuration)\n    {\n        _configuration = configuration;\n    }\n\n    public string[] Get(string key)\n    {\n        return _configuration.ContainsKey(key) ? _configuration[key] : null;\n    }\n}\n")),(0,r.yg)("p",null,"Load configuration and create instance of ",(0,r.yg)("inlineCode",{parentName:"p"},"Configuration")," class"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var configuration = new Configuration(new Dictionary<string, string>() {\n    ["foo"] = "bar"\n});\n')),(0,r.yg)("p",null,"And now you must use instance of ",(0,r.yg)("inlineCode",{parentName:"p"},"Configuration")," in your application."),(0,r.yg)("b",null,"Don't use a Singleton pattern"),(0,r.yg)("p",null,"Singleton is an ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Singleton_pattern"},"anti-pattern"),". Paraphrased from Brian Button:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"They are generally used as a ",(0,r.yg)("strong",{parentName:"li"},"global instance"),", why is that so bad? Because ",(0,r.yg)("strong",{parentName:"li"},"you hide the dependencies")," of your application in your code, instead of exposing them through the interfaces. Making something global to avoid passing it around is a ",(0,r.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Code_smell"},"code smell"),"."),(0,r.yg)("li",{parentName:"ol"},"They violate the ",(0,r.yg)("a",{parentName:"li",href:"#single-responsibility-principle-srp"},"single responsibility principle"),": by virtue of the fact that ",(0,r.yg)("strong",{parentName:"li"},"they control their own creation and lifecycle"),"."),(0,r.yg)("li",{parentName:"ol"},"They inherently cause code to be tightly ",(0,r.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29"},"coupled"),". This makes faking them out under ",(0,r.yg)("strong",{parentName:"li"},"test rather difficult")," in many cases."),(0,r.yg)("li",{parentName:"ol"},"They carry state around for the lifetime of the application. Another hit to testing since ",(0,r.yg)("strong",{parentName:"li"},"you can end up with a situation where tests need to be ordered")," which is a big no for unit tests. Why? Because each unit test should be independent from the other.")),(0,r.yg)("p",null,"There is also very good thoughts by ",(0,r.yg)("a",{parentName:"p",href:"http://misko.hevery.com/about/"},"Misko Hevery")," about the ",(0,r.yg)("a",{parentName:"p",href:"http://misko.hevery.com/2008/08/25/root-cause-of-singletons/"},"root of problem"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class DBConnection\n{\n    private static DBConnection _instance;\n\n    private DBConnection()\n    {\n        // ...\n    }\n\n    public static GetInstance()\n    {\n        if (_instance == null)\n        {\n            _instance = new DBConnection();\n        }\n\n        return _instance;\n    }\n\n    // ...\n}\n\nvar singleton = DBConnection.GetInstance();\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class DBConnection\n{\n    public DBConnection(IOptions<DbConnectionOption> options)\n    {\n        // ...\n    }\n\n    // ...\n}\n")),(0,r.yg)("p",null,"Create instance of ",(0,r.yg)("inlineCode",{parentName:"p"},"DBConnection")," class and configure it with ",(0,r.yg)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1"},"Option pattern"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var options = <resolve from IOC>;\nvar connection = new DBConnection(options);\n")),(0,r.yg)("p",null,"And now you must use instance of ",(0,r.yg)("inlineCode",{parentName:"p"},"DBConnection")," in your application."),(0,r.yg)("b",null,"Function arguments (2 or fewer ideally)"),(0,r.yg)("p",null,"Limiting the amount of function parameters is incredibly important because it makes testing your function easier. Having more than three leads to a combinatorial explosion where you have to test tons of different cases with each separate argument."),(0,r.yg)("p",null,"Zero arguments is the ideal case. One or two arguments is ok, and three should be avoided. Anything more than that should be consolidated. Usually, if you have more than two arguments then your function is trying to do too much. In cases where it's not, most of the time a higher-level object will suffice as an argument."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public void CreateMenu(string title, string body, string buttonText, bool cancellable)\n{\n    // ...\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public class MenuConfig\n{\n    public string Title { get; set; }\n    public string Body { get; set; }\n    public string ButtonText { get; set; }\n    public bool Cancellable { get; set; }\n}\n\nvar config = new MenuConfig\n{\n    Title = "Foo",\n    Body = "Bar",\n    ButtonText = "Baz",\n    Cancellable = true\n};\n\npublic void CreateMenu(MenuConfig config)\n{\n    // ...\n}\n')),(0,r.yg)("b",null,"Functions should do one thing"),(0,r.yg)("p",null,"This is by far the most important rule in software engineering. When functions do more than one thing, they are harder to compose, test, and reason about. When you can isolate a function to just one action, they can be refactored easily and your code will read much\ncleaner. If you take nothing else away from this guide other than this, you'll be ahead of many developers."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public void SendEmailToListOfClients(string[] clients)\n{\n    foreach (var client in clients)\n    {\n        var clientRecord = db.Find(client);\n        if (clientRecord.IsActive())\n        {\n            Email(client);\n        }\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public void SendEmailToListOfClients(string[] clients)\n{\n    var activeClients = GetActiveClients(clients);\n    // Do some logic\n}\n\npublic List<Client> GetActiveClients(string[] clients)\n{\n    return db.Find(clients).Where(s => s.Status == "Active");\n}\n')),(0,r.yg)("b",null,"Function names should say what they do"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Email\n{\n    //...\n\n    public void Handle()\n    {\n        SendMail(this._to, this._subject, this._body);\n    }\n}\n\nvar message = new Email(...);\n// What is this? A handle for the message? Are we writing to a file now?\nmessage.Handle();\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Email\n{\n    //...\n\n    public void Send()\n    {\n        SendMail(this._to, this._subject, this._body);\n    }\n}\n\nvar message = new Email(...);\n// Clear and obvious\nmessage.Send();\n")),(0,r.yg)("b",null,"Functions should only be one level of abstraction"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"Not finished yet")),(0,r.yg)("p",null,"When you have more than one level of abstraction your function is usually doing too much. Splitting up functions leads to reusability and easier testing."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public string ParseBetterJSAlternative(string code)\n{\n    var regexes = [\n        // ...\n    ];\n\n    var statements = explode(" ", code);\n    var tokens = new string[] {};\n    foreach (var regex in regexes)\n    {\n        foreach (var statement in statements)\n        {\n            // ...\n        }\n    }\n\n    var ast = new string[] {};\n    foreach (var token in tokens)\n    {\n        // lex...\n    }\n\n    foreach (var node in ast)\n    {\n        // parse...\n    }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad too:")),(0,r.yg)("p",null,"We have carried out some of the functionality, but the ",(0,r.yg)("inlineCode",{parentName:"p"},"ParseBetterJSAlternative()")," function is still very complex and not testable."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public string Tokenize(string code)\n{\n    var regexes = new string[]\n    {\n        // ...\n    };\n\n    var statements = explode(" ", code);\n    var tokens = new string[] {};\n    foreach (var regex in regexes)\n    {\n        foreach (var statement in statements)\n        {\n            tokens[] = /* ... */;\n        }\n    }\n\n    return tokens;\n}\n\npublic string Lexer(string[] tokens)\n{\n    var ast = new string[] {};\n    foreach (var token in tokens)\n    {\n        ast[] = /* ... */;\n    }\n\n    return ast;\n}\n\npublic string ParseBetterJSAlternative(string code)\n{\n    var tokens = Tokenize(code);\n    var ast = Lexer(tokens);\n    foreach (var node in ast)\n    {\n        // parse...\n    }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("p",null,"The best solution is move out the dependencies of ",(0,r.yg)("inlineCode",{parentName:"p"},"ParseBetterJSAlternative()")," function."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'class Tokenizer\n{\n    public string Tokenize(string code)\n    {\n        var regexes = new string[] {\n            // ...\n        };\n\n        var statements = explode(" ", code);\n        var tokens = new string[] {};\n        foreach (var regex in regexes)\n        {\n            foreach (var statement in statements)\n            {\n                tokens[] = /* ... */;\n            }\n        }\n\n        return tokens;\n    }\n}\n\nclass Lexer\n{\n    public string Lexify(string[] tokens)\n    {\n        var ast = new[] {};\n        foreach (var token in tokens)\n        {\n            ast[] = /* ... */;\n        }\n\n        return ast;\n    }\n}\n\nclass BetterJSAlternative\n{\n    private string _tokenizer;\n    private string _lexer;\n\n    public BetterJSAlternative(Tokenizer tokenizer, Lexer lexer)\n    {\n        _tokenizer = tokenizer;\n        _lexer = lexer;\n    }\n\n    public string Parse(string code)\n    {\n        var tokens = _tokenizer.Tokenize(code);\n        var ast = _lexer.Lexify(tokens);\n        foreach (var node in ast)\n        {\n            // parse...\n        }\n    }\n}\n')),(0,r.yg)("b",null,"Function callers and callees should be close"),(0,r.yg)("p",null,"If a function calls another, keep those functions vertically close in the source file. Ideally, keep the caller right above the callee. We tend to read code from top-to-bottom, like a newspaper. Because of this, make your code read that way."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class PerformanceReview\n{\n    private readonly Employee _employee;\n\n    public PerformanceReview(Employee employee)\n    {\n        _employee = employee;\n    }\n\n    private IEnumerable<PeersData> LookupPeers()\n    {\n        return db.lookup(_employee, 'peers');\n    }\n\n    private ManagerData LookupManager()\n    {\n        return db.lookup(_employee, 'manager');\n    }\n\n    private IEnumerable<PeerReviews> GetPeerReviews()\n    {\n        var peers = LookupPeers();\n        // ...\n    }\n\n    public PerfReviewData PerfReview()\n    {\n        GetPeerReviews();\n        GetManagerReview();\n        GetSelfReview();\n    }\n\n    public ManagerData GetManagerReview()\n    {\n        var manager = LookupManager();\n    }\n\n    public EmployeeData GetSelfReview()\n    {\n        // ...\n    }\n}\n\nvar  review = new PerformanceReview(employee);\nreview.PerfReview();\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class PerformanceReview\n{\n    private readonly Employee _employee;\n\n    public PerformanceReview(Employee employee)\n    {\n        _employee = employee;\n    }\n\n    public PerfReviewData PerfReview()\n    {\n        GetPeerReviews();\n        GetManagerReview();\n        GetSelfReview();\n    }\n\n    private IEnumerable<PeerReviews> GetPeerReviews()\n    {\n        var peers = LookupPeers();\n        // ...\n    }\n\n    private IEnumerable<PeersData> LookupPeers()\n    {\n        return db.lookup(_employee, 'peers');\n    }\n\n    private ManagerData GetManagerReview()\n    {\n        var manager = LookupManager();\n        return manager;\n    }\n\n    private ManagerData LookupManager()\n    {\n        return db.lookup(_employee, 'manager');\n    }\n\n    private EmployeeData GetSelfReview()\n    {\n        // ...\n    }\n}\n\nvar review = new PerformanceReview(employee);\nreview.PerfReview();\n")),(0,r.yg)("b",null,"Encapsulate conditionals"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'if (article.state == "published")\n{\n    // ...\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"if (article.IsPublished())\n{\n    // ...\n}\n")),(0,r.yg)("b",null,"Remove dead code"),(0,r.yg)("p",null,"Dead code is just as bad as duplicate code. There's no reason to keep it in your codebase. If it's not being called, get rid of it! It will still be safe in your version history if you still need it."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public void OldRequestModule(string url)\n{\n    // ...\n}\n\npublic void NewRequestModule(string url)\n{\n    // ...\n}\n\nvar request = NewRequestModule(requestUrl);\nInventoryTracker("apples", request, "www.inventory-awesome.io");\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public void RequestModule(string url)\n{\n    // ...\n}\n\nvar request = RequestModule(requestUrl);\nInventoryTracker("apples", request, "www.inventory-awesome.io");\n')),(0,r.yg)("h2",{id:"objects-and-data-structures"},"Objects and Data Structures"),(0,r.yg)("b",null,"Use getters and setters"),(0,r.yg)("p",null,"In C# / VB.NET you can set ",(0,r.yg)("inlineCode",{parentName:"p"},"public"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"protected")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"private")," keywords for methods.\nUsing it, you can control properties modification on an object."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"When you want to do more beyond getting an object property, you don't have to look up and change every accessor in your codebase."),(0,r.yg)("li",{parentName:"ul"},"Makes adding validation simple when doing a ",(0,r.yg)("inlineCode",{parentName:"li"},"set"),"."),(0,r.yg)("li",{parentName:"ul"},"Encapsulates the internal representation."),(0,r.yg)("li",{parentName:"ul"},"Easy to add logging and error handling when getting and setting."),(0,r.yg)("li",{parentName:"ul"},"Inheriting this class, you can override default functionality."),(0,r.yg)("li",{parentName:"ul"},"You can lazy load your object's properties, let's say getting it from a server.")),(0,r.yg)("p",null,"Additionally, this is part of Open/Closed principle, from object-oriented design principles."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class BankAccount\n{\n    public double Balance = 1000;\n}\n\nvar bankAccount = new BankAccount();\n\n// Fake buy shoes...\nbankAccount.Balance -= 100;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class BankAccount\n{\n    private double _balance = 0.0D;\n\n    pubic double Balance {\n        get {\n            return _balance;\n        }\n    }\n\n    public BankAccount(balance = 1000)\n    {\n       _balance = balance;\n    }\n\n    public void WithdrawBalance(int amount)\n    {\n        if (amount > _balance)\n        {\n            throw new Exception('Amount greater than available balance.');\n        }\n\n        _balance -= amount;\n    }\n\n    public void DepositBalance(int amount)\n    {\n        _balance += amount;\n    }\n}\n\nvar bankAccount = new BankAccount();\n\n// Buy shoes...\nbankAccount.WithdrawBalance(price);\n\n// Get balance\nbalance = bankAccount.Balance;\n")),(0,r.yg)("b",null,"Make objects have private/protected members"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'class Employee\n{\n    public string Name { get; set; }\n\n    public Employee(string name)\n    {\n        Name = name;\n    }\n}\n\nvar employee = new Employee("John Doe");\nConsole.WriteLine(employee.Name); // Employee name: John Doe\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'class Employee\n{\n    public string Name { get; }\n\n    public Employee(string name)\n    {\n        Name = name;\n    }\n}\n\nvar employee = new Employee("John Doe");\nConsole.WriteLine(employee.Name); // Employee name: John Doe\n')),(0,r.yg)("h2",{id:"classes"},"Classes"),(0,r.yg)("b",null,"Use method chaining"),(0,r.yg)("p",null,"This pattern is very useful and commonly used in many libraries. It allows your code to be expressive, and less verbose.\nFor that reason, use method chaining and take a look at how clean your code will be."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public static class ListExtensions\n{\n    public static List<T> FluentAdd<T>(this List<T> list, T item)\n    {\n        list.Add(item);\n        return list;\n    }\n\n    public static List<T> FluentClear<T>(this List<T> list)\n    {\n        list.Clear();\n        return list;\n    }\n\n    public static List<T> FluentForEach<T>(this List<T> list, Action<T> action)\n    {\n        list.ForEach(action);\n        return list;\n    }\n\n    public static List<T> FluentInsert<T>(this List<T> list, int index, T item)\n    {\n        list.Insert(index, item);\n        return list;\n    }\n\n    public static List<T> FluentRemoveAt<T>(this List<T> list, int index)\n    {\n        list.RemoveAt(index);\n        return list;\n    }\n\n    public static List<T> FluentReverse<T>(this List<T> list)\n    {\n        list.Reverse();\n        return list;\n    }\n}\n\ninternal static void ListFluentExtensions()\n{\n    var list = new List<int>() { 1, 2, 3, 4, 5 }\n        .FluentAdd(1)\n        .FluentInsert(0, 0)\n        .FluentRemoveAt(1)\n        .FluentReverse()\n        .FluentForEach(value => value.WriteLine())\n        .FluentClear();\n}\n")),(0,r.yg)("b",null,"Prefer composition over inheritance"),(0,r.yg)("p",null,"As stated famously in ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Design_Patterns"},(0,r.yg)("em",{parentName:"a"},"Design Patterns"))," by the Gang of Four,\nyou should prefer composition over inheritance where you can. There are lots of good reasons to use inheritance and lots of good reasons to use composition."),(0,r.yg)("p",null,"The main point for this maxim is that if your mind instinctively goes for inheritance, try to think if composition could model your problem better. In some cases it can."),(0,r.yg)("p",null,'You might be wondering then, "when should I use inheritance?" It\ndepends on your problem at hand, but this is a decent list of when inheritance makes more sense than composition:'),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},'Your inheritance represents an "is-a" relationship and not a "has-a" relationship (Human->Animal vs. User->UserDetails).'),(0,r.yg)("li",{parentName:"ol"},"You can reuse code from the base classes (Humans can move like all animals)."),(0,r.yg)("li",{parentName:"ol"},"You want to make global changes to derived classes by changing a base class (Change the caloric expenditure of all animals when they move).")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'class Employee\n{\n    private string Name { get; set; }\n    private string Email { get; set; }\n\n    public Employee(string name, string email)\n    {\n        Name = name;\n        Email = email;\n    }\n\n    // ...\n}\n\n// Bad because Employees "have" tax data.\n// EmployeeTaxData is not a type of Employee\n\nclass EmployeeTaxData : Employee\n{\n    private string Name { get; }\n    private string Email { get; }\n\n    public EmployeeTaxData(string name, string email, string ssn, string salary)\n    {\n         // ...\n    }\n\n    // ...\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class EmployeeTaxData\n{\n    public string Ssn { get; }\n    public string Salary { get; }\n\n    public EmployeeTaxData(string ssn, string salary)\n    {\n        Ssn = ssn;\n        Salary = salary;\n    }\n\n    // ...\n}\n\nclass Employee\n{\n    public string Name { get; }\n    public string Email { get; }\n    public EmployeeTaxData TaxData { get; }\n\n    public Employee(string name, string email)\n    {\n        Name = name;\n        Email = email;\n    }\n\n    public void SetTax(string ssn, double salary)\n    {\n        TaxData = new EmployeeTaxData(ssn, salary);\n    }\n\n    // ...\n}\n")),(0,r.yg)("h2",{id:"solid"},"SOLID"),(0,r.yg)("b",null,"What is SOLID?"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"SOLID")," is the mnemonic acronym introduced by Michael Feathers for the first five principles named by Robert Martin, which meant five basic principles of object-oriented programming and design."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"#single-responsibility-principle-srp"},"S: Single Responsibility Principle (SRP)")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"#openclosed-principle-ocp"},"O: Open/Closed Principle (OCP)")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"#liskov-substitution-principle-lsp"},"L: Liskov Substitution Principle (LSP)")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"#interface-segregation-principle-isp"},"I: Interface Segregation Principle (ISP)")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"#dependency-inversion-principle-dip"},"D: Dependency Inversion Principle (DIP)"))),(0,r.yg)("b",null,"Single Responsibility Principle (SRP)"),(0,r.yg)("p",null,"As stated in Clean Code, \"There should never be more than one reason for a class to change\". It's tempting to jam-pack a class with a lot of functionality, like when you can only take one suitcase on your flight. The issue with this is that your class won't be conceptually cohesive and it will give it many reasons to change. Minimizing the amount of times you need to change a class is important."),(0,r.yg)("p",null,"It's important because if too much functionality is in one class and you modify a piece of it, it can be difficult to understand how that will affect other dependent modules in your codebase."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class UserSettings\n{\n    private User User;\n\n    public UserSettings(User user)\n    {\n        User = user;\n    }\n\n    public void ChangeSettings(Settings settings)\n    {\n        if (verifyCredentials())\n        {\n            // ...\n        }\n    }\n\n    private bool VerifyCredentials()\n    {\n        // ...\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class UserAuth\n{\n    private User User;\n\n    public UserAuth(User user)\n    {\n        User = user;\n    }\n\n    public bool VerifyCredentials()\n    {\n        // ...\n    }\n}\n\nclass UserSettings\n{\n    private User User;\n    private UserAuth Auth;\n\n    public UserSettings(User user)\n    {\n        User = user;\n        Auth = new UserAuth(user);\n    }\n\n    public void ChangeSettings(Settings settings)\n    {\n        if (Auth.VerifyCredentials())\n        {\n            // ...\n        }\n    }\n}\n")),(0,r.yg)("b",null,"Open/Closed Principle (OCP)"),(0,r.yg)("p",null,'As stated by Bertrand Meyer, "software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification." What does that mean though? This principle basically states that you should allow users to add new functionalities without changing existing code.'),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'abstract class AdapterBase\n{\n    protected string Name;\n\n    public string GetName()\n    {\n        return Name;\n    }\n}\n\nclass AjaxAdapter : AdapterBase\n{\n    public AjaxAdapter()\n    {\n        Name = "ajaxAdapter";\n    }\n}\n\nclass NodeAdapter : AdapterBase\n{\n    public NodeAdapter()\n    {\n        Name = "nodeAdapter";\n    }\n}\n\nclass HttpRequester : AdapterBase\n{\n    private readonly AdapterBase Adapter;\n\n    public HttpRequester(AdapterBase adapter)\n    {\n        Adapter = adapter;\n    }\n\n    public bool Fetch(string url)\n    {\n        var adapterName = Adapter.GetName();\n\n        if (adapterName == "ajaxAdapter")\n        {\n            return MakeAjaxCall(url);\n        }\n        else if (adapterName == "httpNodeAdapter")\n        {\n            return MakeHttpCall(url);\n        }\n    }\n\n    private bool MakeAjaxCall(string url)\n    {\n        // request and return promise\n    }\n\n    private bool MakeHttpCall(string url)\n    {\n        // request and return promise\n    }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"interface IAdapter\n{\n    bool Request(string url);\n}\n\nclass AjaxAdapter : IAdapter\n{\n    public bool Request(string url)\n    {\n        // request and return promise\n    }\n}\n\nclass NodeAdapter : IAdapter\n{\n    public bool Request(string url)\n    {\n        // request and return promise\n    }\n}\n\nclass HttpRequester\n{\n    private readonly IAdapter Adapter;\n\n    public HttpRequester(IAdapter adapter)\n    {\n        Adapter = adapter;\n    }\n\n    public bool Fetch(string url)\n    {\n        return Adapter.Request(url);\n    }\n}\n")),(0,r.yg)("b",null,"Liskov Substitution Principle (LSP)"),(0,r.yg)("p",null,"This is a scary term for a very simple concept. It's formally defined as \"If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed,\netc.).\" That's an even scarier definition."),(0,r.yg)("p",null,'The best explanation for this is if you have a parent class and a child class, then the base class and child class can be used interchangeably without getting incorrect results. This might still be confusing, so let\'s take a look at the classic Square-Rectangle example. Mathematically, a square is a rectangle, but if you model it using the "is-a" relationship via inheritance, you quickly\nget into trouble.'),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"class Rectangle\n{\n    protected double Width = 0;\n    protected double Height = 0;\n\n    public Drawable Render(double area)\n    {\n        // ...\n    }\n\n    public void SetWidth(double width)\n    {\n        Width = width;\n    }\n\n    public void SetHeight(double height)\n    {\n        Height = height;\n    }\n\n    public double GetArea()\n    {\n        return Width * Height;\n    }\n}\n\nclass Square : Rectangle\n{\n    public double SetWidth(double width)\n    {\n        Width = Height = width;\n    }\n\n    public double SetHeight(double height)\n    {\n        Width = Height = height;\n    }\n}\n\nDrawable RenderLargeRectangles(Rectangle rectangles)\n{\n    foreach (rectangle in rectangles)\n    {\n        rectangle.SetWidth(4);\n        rectangle.SetHeight(5);\n        var area = rectangle.GetArea(); // BAD: Will return 25 for Square. Should be 20.\n        rectangle.Render(area);\n    }\n}\n\nvar rectangles = new[] { new Rectangle(), new Rectangle(), new Square() };\nRenderLargeRectangles(rectangles);\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"abstract class ShapeBase\n{\n    protected double Width = 0;\n    protected double Height = 0;\n\n    abstract public double GetArea();\n\n    public Drawable Render(double area)\n    {\n        // ...\n    }\n}\n\nclass Rectangle : ShapeBase\n{\n    public void SetWidth(double width)\n    {\n        Width = width;\n    }\n\n    public void SetHeight(double height)\n    {\n        Height = height;\n    }\n\n    public double GetArea()\n    {\n        return Width * Height;\n    }\n}\n\nclass Square : ShapeBase\n{\n    private double Length = 0;\n\n    public double SetLength(double length)\n    {\n        Length = length;\n    }\n\n    public double GetArea()\n    {\n        return Math.Pow(Length, 2);\n    }\n}\n\nDrawable RenderLargeRectangles(Rectangle rectangles)\n{\n    foreach (rectangle in rectangles)\n    {\n        if (rectangle is Square)\n        {\n            rectangle.SetLength(5);\n        }\n        else if (rectangle is Rectangle)\n        {\n            rectangle.SetWidth(4);\n            rectangle.SetHeight(5);\n        }\n\n        var area = rectangle.GetArea();\n        rectangle.Render(area);\n    }\n}\n\nvar shapes = new[] { new Rectangle(), new Rectangle(), new Square() };\nRenderLargeRectangles(shapes);\n")),(0,r.yg)("b",null,"Interface Segregation Principle (ISP)"),(0,r.yg)("p",null,'ISP states that "Clients should not be forced to depend upon interfaces that they do not use."'),(0,r.yg)("p",null,'A good example to look at that demonstrates this principle is for\nclasses that require large settings objects. Not requiring clients to setup huge amounts of options is beneficial, because most of the time they won\'t need all of the settings. Making them optional helps prevent having a "fat interface".'),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public interface IEmployee\n{\n    void Work();\n    void Eat();\n}\n\npublic class Human : IEmployee\n{\n    public void Work()\n    {\n        // ....working\n    }\n\n    public void Eat()\n    {\n        // ...... eating in lunch break\n    }\n}\n\npublic class Robot : IEmployee\n{\n    public void Work()\n    {\n        //.... working much more\n    }\n\n    public void Eat()\n    {\n        //.... robot can't eat, but it must implement this method\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("p",null,"Not every worker is an employee, but every employee is an worker."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public interface IWorkable\n{\n    void Work();\n}\n\npublic interface IFeedable\n{\n    void Eat();\n}\n\npublic interface IEmployee : IFeedable, IWorkable\n{\n}\n\npublic class Human : IEmployee\n{\n    public void Work()\n    {\n        // ....working\n    }\n\n    public void Eat()\n    {\n        //.... eating in lunch break\n    }\n}\n\n// robot can only work\npublic class Robot : IWorkable\n{\n    public void Work()\n    {\n        // ....working\n    }\n}\n")),(0,r.yg)("b",null,"Dependency Inversion Principle (DIP)"),(0,r.yg)("p",null,"This principle states two essential things:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"High-level modules should not depend on low-level modules. Both should depend on abstractions."),(0,r.yg)("li",{parentName:"ol"},"Abstractions should not depend upon details. Details should depend on abstractions.")),(0,r.yg)("p",null,"This can be hard to understand at first, but if you've worked with .NET/.NET Core framework, you've seen an implementation of this principle in the form of ",(0,r.yg)("a",{parentName:"p",href:"https://martinfowler.com/articles/injection.html"},"Dependency Injection")," (DI). While they are not identical concepts, DIP keeps high-level modules from knowing the details of its low-level modules and setting them up.\nIt can accomplish this through DI. A huge benefit of this is that it reduces the coupling between modules. Coupling is a very bad development pattern because it makes your code hard to refactor."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public abstract class EmployeeBase\n{\n    protected virtual void Work()\n    {\n        // ....working\n    }\n}\n\npublic class Human : EmployeeBase\n{\n    public override void Work()\n    {\n        //.... working much more\n    }\n}\n\npublic class Robot : EmployeeBase\n{\n    public override void Work()\n    {\n        //.... working much, much more\n    }\n}\n\npublic class Manager\n{\n    private readonly Robot _robot;\n    private readonly Human _human;\n\n    public Manager(Robot robot, Human human)\n    {\n        _robot = robot;\n        _human = human;\n    }\n\n    public void Manage()\n    {\n        _robot.Work();\n        _human.Work();\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public interface IEmployee\n{\n    void Work();\n}\n\npublic class Human : IEmployee\n{\n    public void Work()\n    {\n        // ....working\n    }\n}\n\npublic class Robot : IEmployee\n{\n    public void Work()\n    {\n        //.... working much more\n    }\n}\n\npublic class Manager\n{\n    private readonly IEnumerable<IEmployee> _employees;\n\n    public Manager(IEnumerable<IEmployee> employees)\n    {\n        _employees = employees;\n    }\n\n    public void Manage()\n    {\n        foreach (var employee in _employees)\n        {\n            _employee.Work();\n        }\n    }\n}\n")),(0,r.yg)("b",null,"Don\u2019t repeat yourself (DRY)"),(0,r.yg)("p",null,"Try to observe the ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"},"DRY")," principle."),(0,r.yg)("p",null,"Do your absolute best to avoid duplicate code. Duplicate code is bad because it means that there's more than one place to alter something if you need to change some logic."),(0,r.yg)("p",null,"Imagine if you run a restaurant and you keep track of your inventory: all your tomatoes, onions, garlic, spices, etc. If you have multiple lists that you keep this on, then all have to be updated when you serve a dish with tomatoes in them. If you only have one list, there's only one place to update!"),(0,r.yg)("p",null,"Oftentimes you have duplicate code because you have two or more slightly different things, that share a lot in common, but their differences force you to have two or more separate functions that do much of the same things. Removing duplicate code means creating an abstraction that can handle this set of different things with just one function/module/class."),(0,r.yg)("p",null,"Getting the abstraction right is critical, that's why you should follow the SOLID principles laid out in the ",(0,r.yg)("a",{parentName:"p",href:"#classes"},"Classes")," section. Bad abstractions can be worse than duplicate code, so be careful! Having said this, if you can make a good abstraction, do it! Don't repeat yourself, otherwise you'll find yourself updating multiple places anytime you want to change one thing."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public List<EmployeeData> ShowDeveloperList(Developers developers)\n{\n    foreach (var developers in developer)\n    {\n        var expectedSalary = developer.CalculateExpectedSalary();\n        var experience = developer.GetExperience();\n        var githubLink = developer.GetGithubLink();\n        var data = new[] {\n            expectedSalary,\n            experience,\n            githubLink\n        };\n\n        Render(data);\n    }\n}\n\npublic List<ManagerData> ShowManagerList(Manager managers)\n{\n    foreach (var manager in managers)\n    {\n        var expectedSalary = manager.CalculateExpectedSalary();\n        var experience = manager.GetExperience();\n        var githubLink = manager.GetGithubLink();\n        var data =\n        new[] {\n            expectedSalary,\n            experience,\n            githubLink\n        };\n\n        render(data);\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public List<EmployeeData> ShowList(Employee employees)\n{\n    foreach (var employee in employees)\n    {\n        var expectedSalary = employees.CalculateExpectedSalary();\n        var experience = employees.GetExperience();\n        var githubLink = employees.GetGithubLink();\n        var data =\n        new[] {\n            expectedSalary,\n            experience,\n            githubLink\n        };\n\n        render(data);\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Very good:")),(0,r.yg)("p",null,"It is better to use a compact version of the code."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public List<EmployeeData> ShowList(Employee employees)\n{\n    foreach (var employee in employees)\n    {\n        render(new[] {\n            employee.CalculateExpectedSalary(),\n            employee.GetExperience(),\n            employee.GetGithubLink()\n        });\n    }\n}\n")),(0,r.yg)("h2",{id:"testing"},"Testing"),(0,r.yg)("b",null,"Basic concept of testing"),(0,r.yg)("p",null,"Testing is more important than shipping. If you have no tests or an\ninadequate amount, then every time you ship code you won't be sure that you didn't break anything. Deciding on what constitutes an adequate amount is up to your team, but having 100% coverage (all statements and branches) is how you achieve very high confidence and developer peace of mind. This means that in addition to having a great testing framework, you also need to use a ",(0,r.yg)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested"},"good coverage tool"),"."),(0,r.yg)("p",null,"There's no excuse to not write tests. There's ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/thangchung/awesome-dotnet-core#testing"},"plenty of good .NET test frameworks"),", so find one that your team prefers. When you find one that works for your team, then aim to always write tests for every new feature/module you introduce. If your preferred method is Test Driven Development (TDD), that is great, but the main point is to just make sure you are reaching your coverage goals before launching any feature, or refactoring an existing one."),(0,r.yg)("b",null,"Single concept per test"),(0,r.yg)("p",null,"Ensures that your tests are laser focused and not testing miscellaenous (non-related) things, forces ",(0,r.yg)("a",{parentName:"p",href:"http://wiki.c2.com/?ArrangeActAssert"},"AAA patern")," used to make your codes more clean and readable."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'\npublic class MakeDotNetGreatAgainTests\n{\n    [Fact]\n    public void HandleDateBoundaries()\n    {\n        var date = new MyDateTime("1/1/2015");\n        date.AddDays(30);\n        Assert.Equal("1/31/2015", date);\n\n        date = new MyDateTime("2/1/2016");\n        date.AddDays(28);\n        Assert.Equal("02/29/2016", date);\n\n        date = new MyDateTime("2/1/2015");\n        date.AddDays(28);\n        Assert.Equal("03/01/2015", date);\n    }\n}\n\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'\npublic class MakeDotNetGreatAgainTests\n{\n    [Fact]\n    public void Handle30DayMonths()\n    {\n        // Arrange\n        var date = new MyDateTime("1/1/2015");\n\n        // Act\n        date.AddDays(30);\n\n        // Assert\n        Assert.Equal("1/31/2015", date);\n    }\n\n    [Fact]\n    public void HandleLeapYear()\n    {\n        // Arrange\n        var date = new MyDateTime("2/1/2016");\n\n        // Act\n        date.AddDays(28);\n\n        // Assert\n        Assert.Equal("02/29/2016", date);\n    }\n\n    [Fact]\n    public void HandleNonLeapYear()\n    {\n        // Arrange\n        var date = new MyDateTime("2/1/2015");\n\n        // Act\n        date.AddDays(28);\n\n        // Assert\n        Assert.Equal("03/01/2015", date);\n    }\n}\n\n')),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"Soure ",(0,r.yg)("a",{parentName:"p",href:"https://www.codingblocks.net/podcast/how-to-write-amazing-unit-tests"},"https://www.codingblocks.net/podcast/how-to-write-amazing-unit-tests"))),(0,r.yg)("h2",{id:"concurrency"},"Concurrency"),(0,r.yg)("b",null,"Use Async/Await"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Summary of Asynchronous Programming Guidelines")),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Name"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"),(0,r.yg)("th",{parentName:"tr",align:null},"Exceptions"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Avoid async void"),(0,r.yg)("td",{parentName:"tr",align:null},"Prefer async Task methods over async void methods"),(0,r.yg)("td",{parentName:"tr",align:null},"Event handlers")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Async all the way"),(0,r.yg)("td",{parentName:"tr",align:null},"Don't mix blocking and async code"),(0,r.yg)("td",{parentName:"tr",align:null},"Console main method (C# <= 7.0)")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Configure context"),(0,r.yg)("td",{parentName:"tr",align:null},"Use ",(0,r.yg)("inlineCode",{parentName:"td"},"ConfigureAwait(false)")," when you can"),(0,r.yg)("td",{parentName:"tr",align:null},"Methods that require con\xadtext")))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"The Async Way of Doing Things")),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"To Do This ..."),(0,r.yg)("th",{parentName:"tr",align:null},"Instead of This ..."),(0,r.yg)("th",{parentName:"tr",align:null},"Use This"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Retrieve the result of a background task"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task.Wait or Task.Result")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Wait for any task to complete"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task.WaitAny")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await Task.WhenAny"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Retrieve the results of multiple tasks"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task.WaitAll")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await Task.WhenAll"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Wait a period of time"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Thread.Sleep")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await Task.Delay"))))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Best practice")),(0,r.yg)("p",null,"The async/await is the best for IO bound tasks (networking communication, database communication, http request, etc.) but it is not good to apply on computational bound tasks (traverse on the huge list, render a hugge image, etc.). Because it will release the holding thread to the thread pool and CPU/cores available will not involve to process those tasks. Therefore, we should avoid using Async/Await for computional bound tasks."),(0,r.yg)("p",null,"For dealing with computational bound tasks, prefer to use ",(0,r.yg)("inlineCode",{parentName:"p"},"Task.Factory.CreateNew")," with ",(0,r.yg)("inlineCode",{parentName:"p"},"TaskCreationOptions")," is ",(0,r.yg)("inlineCode",{parentName:"p"},"LongRunning"),". It will start a new background thread to process a heavy computational bound task without release it back to the thread pool until the task being completed."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Know Your Tools")),(0,r.yg)("p",null,"There's a lot to learn about async and await, and it's natural to get a little disoriented. Here's a quick reference of solutions to common problems."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Solutions to Common Async Problems")),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Problem"),(0,r.yg)("th",{parentName:"tr",align:null},"Solution"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Create a task to execute code"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task.Run")," or ",(0,r.yg)("inlineCode",{parentName:"td"},"TaskFactory.StartNew")," (not the ",(0,r.yg)("inlineCode",{parentName:"td"},"Task")," constructor or ",(0,r.yg)("inlineCode",{parentName:"td"},"Task.Start"),")")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Create a task wrapper for an operation or event"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"TaskFactory.FromAsync")," or ",(0,r.yg)("inlineCode",{parentName:"td"},"TaskCompletionSource<T>"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Support cancellation"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"CancellationTokenSource")," and ",(0,r.yg)("inlineCode",{parentName:"td"},"CancellationToken"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Report progress"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"IProgress<T>")," and ",(0,r.yg)("inlineCode",{parentName:"td"},"Progress<T>"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Handle streams of data"),(0,r.yg)("td",{parentName:"tr",align:null},"TPL Dataflow or Reactive Extensions")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Synchronize access to a shared resource"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"SemaphoreSlim"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Asynchronously initialize a resource"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"AsyncLazy<T>"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Async-ready producer/consumer structures"),(0,r.yg)("td",{parentName:"tr",align:null},"TPL Dataflow or ",(0,r.yg)("inlineCode",{parentName:"td"},"AsyncCollection<T>"))))),(0,r.yg)("p",null,"Read the ",(0,r.yg)("a",{parentName:"p",href:"http://www.microsoft.com/download/en/details.aspx?id=19957"},"Task-based Asynchronous Pattern (TAP) document"),".\nIt is extremely well-written, and includes guidance on API design and the proper use of async/await (including cancellation and progress reporting)."),(0,r.yg)("p",null,"There are many new await-friendly techniques that should be used instead of the old blocking techniques. If you have any of these Old examples in your new async code, you're Doing It Wrong(TM):"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Old"),(0,r.yg)("th",{parentName:"tr",align:null},"New"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"task.Wait")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await task")),(0,r.yg)("td",{parentName:"tr",align:null},"Wait/await for a task to complete")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"task.Result")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await task")),(0,r.yg)("td",{parentName:"tr",align:null},"Get the result of a completed task")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task.WaitAny")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await Task.WhenAny")),(0,r.yg)("td",{parentName:"tr",align:null},"Wait/await for one of a collection of tasks to complete")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task.WaitAll")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await Task.WhenAll")),(0,r.yg)("td",{parentName:"tr",align:null},"Wait/await for every one of a collection of tasks to complete")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Thread.Sleep")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"await Task.Delay")),(0,r.yg)("td",{parentName:"tr",align:null},"Wait/await for a period of time")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task")," constructor"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task.Run")," or ",(0,r.yg)("inlineCode",{parentName:"td"},"TaskFactory.StartNew")),(0,r.yg)("td",{parentName:"tr",align:null},"Create a code-based task")))),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"Source ",(0,r.yg)("a",{parentName:"p",href:"https://gist.github.com/jonlabelle/841146854b23b305b50fa5542f84b20c"},"https://gist.github.com/jonlabelle/841146854b23b305b50fa5542f84b20c"))),(0,r.yg)("h2",{id:"error-handling"},"Error Handling"),(0,r.yg)("b",null,"Basic concept of error handling"),(0,r.yg)("p",null,"Thrown errors are a good thing! They mean the runtime has successfully identified when something in your program has gone wrong and it's letting you know by stopping function execution on the current stack, killing the process (in .NET/.NET Core), and notifying you in the console with a stack trace."),(0,r.yg)("b",null,"Don't use 'throw ex' in catch block"),(0,r.yg)("p",null,"If you need to re-throw an exception after catching it, use just 'throw'\nBy using this, you will save the stack trace. But in the bad option below,\nyou will lost the stack trace."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    // Do something..\n}\ncatch (Exception ex)\n{\n    // Any action something like roll-back or logging etc.\n    throw ex;\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    // Do something..\n}\ncatch (Exception ex)\n{\n    // Any action something like roll-back or logging etc.\n    throw;\n}\n")),(0,r.yg)("b",null,"Don't ignore caught errors"),(0,r.yg)("p",null,"Doing nothing with a caught error doesn't give you the ability to ever fix or react to said error. Throwing the error isn't much better as often times it can get lost in a sea of things printed to the console. If you wrap any bit of code in a ",(0,r.yg)("inlineCode",{parentName:"p"},"try/catch")," it means you think an error may occur there and therefore you should have a plan, or create a code path, for when it occurs."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception ex)\n{\n    // silent exception\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception error)\n{\n    NotifyUserOfError(error);\n\n    // Another option\n    ReportErrorToService(error);\n}\n")),(0,r.yg)("b",null,"Use multiple catch block instead of if conditions."),(0,r.yg)("p",null,"If you need to take action according to type of the exception,\nyou better use multiple catch block for exception handling."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    // Do something..\n}\ncatch (Exception ex)\n{\n\n    if (ex is TaskCanceledException)\n    {\n        // Take action for TaskCanceledException\n    }\n    else if (ex is TaskSchedulerException)\n    {\n        // Take action for TaskSchedulerException\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    // Do something..\n}\ncatch (TaskCanceledException ex)\n{\n    // Take action for TaskCanceledException\n}\ncatch (TaskSchedulerException ex)\n{\n    // Take action for TaskSchedulerException\n}\n")),(0,r.yg)("b",null,"Keep exception stack trace when rethrowing exceptions"),(0,r.yg)("p",null,"C# allows the exception to be rethrown in a catch block using the ",(0,r.yg)("inlineCode",{parentName:"p"},"throw")," keyword. It is a bad practice to throw a caught exception using ",(0,r.yg)("inlineCode",{parentName:"p"},"throw e;"),". This statement resets the stack trace. Instead use ",(0,r.yg)("inlineCode",{parentName:"p"},"throw;"),". This will keep the stack trace and provide a deeper insight about the exception.\nAnother option is to use a custom exception. Simply instantiate a new exception and set its inner exception property to the caught exception with throw ",(0,r.yg)("inlineCode",{parentName:"p"},'new CustomException("some info", e);'),". Adding information to an exception is a good practice as it will help with debugging. However, if the objective is to log an exception then use ",(0,r.yg)("inlineCode",{parentName:"p"},"throw;")," to pass the buck to the caller."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception ex)\n{\n    logger.LogInfo(ex);\n    throw ex;\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception error)\n{\n    logger.LogInfo(error);\n    throw;\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception error)\n{\n    logger.LogInfo(error);\n    throw new CustomException(error);\n}\n")),(0,r.yg)("h2",{id:"formatting"},"Formatting"),(0,r.yg)("b",null,"Uses ",(0,r.yg)("i",null,".editorconfig")," file"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("p",null,"Has many code formatting styles in the project. For example, indent style is ",(0,r.yg)("inlineCode",{parentName:"p"},"space")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"tab")," mixed in the project."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("p",null,"Define and maintain consistent code style in your codebase with the use of an ",(0,r.yg)("inlineCode",{parentName:"p"},".editorconfig")," file"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"root = true\n\n[*]\nindent_style = space\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n# C# files\n[*.cs]\nindent_size = 4\n# New line preferences\ncsharp_new_line_before_open_brace = all\ncsharp_new_line_before_else = true\ncsharp_new_line_before_catch = true\ncsharp_new_line_before_finally = true\ncsharp_new_line_before_members_in_object_initializers = true\ncsharp_new_line_before_members_in_anonymous_types = true\ncsharp_new_line_within_query_expression_clauses = true\n\n# Code files\n[*.{cs,csx,vb,vbx}]\nindent_size = 4\n\n# Indentation preferences\ncsharp_indent_block_contents = true\ncsharp_indent_braces = false\ncsharp_indent_case_contents = true\ncsharp_indent_switch_labels = true\ncsharp_indent_labels = one_less_than_current\n\n# avoid this. unless absolutely necessary\ndotnet_style_qualification_for_field = false:suggestion\ndotnet_style_qualification_for_property = false:suggestion\ndotnet_style_qualification_for_method = false:suggestion\ndotnet_style_qualification_for_event = false:suggestion\n\n# only use var when it's obvious what the variable type is\n# csharp_style_var_for_built_in_types = false:none\n# csharp_style_var_when_type_is_apparent = false:none\n# csharp_style_var_elsewhere = false:suggestion\n\n# use language keywords instead of BCL types\ndotnet_style_predefined_type_for_locals_parameters_members = true:suggestion\ndotnet_style_predefined_type_for_member_access = true:suggestion\n\n# name all constant fields using PascalCase\ndotnet_naming_rule.constant_fields_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.constant_fields_should_be_pascal_case.symbols  = constant_fields\ndotnet_naming_rule.constant_fields_should_be_pascal_case.style    = pascal_case_style\n\ndotnet_naming_symbols.constant_fields.applicable_kinds   = field\ndotnet_naming_symbols.constant_fields.required_modifiers = const\n\ndotnet_naming_style.pascal_case_style.capitalization = pascal_case\n\n# static fields should have s_ prefix\ndotnet_naming_rule.static_fields_should_have_prefix.severity = suggestion\ndotnet_naming_rule.static_fields_should_have_prefix.symbols  = static_fields\ndotnet_naming_rule.static_fields_should_have_prefix.style    = static_prefix_style\n\ndotnet_naming_symbols.static_fields.applicable_kinds   = field\ndotnet_naming_symbols.static_fields.required_modifiers = static\n\ndotnet_naming_style.static_prefix_style.required_prefix = s_\ndotnet_naming_style.static_prefix_style.capitalization = camel_case\n\n# internal and private fields should be _camelCase\ndotnet_naming_rule.camel_case_for_private_internal_fields.severity = suggestion\ndotnet_naming_rule.camel_case_for_private_internal_fields.symbols  = private_internal_fields\ndotnet_naming_rule.camel_case_for_private_internal_fields.style    = camel_case_underscore_style\n\ndotnet_naming_symbols.private_internal_fields.applicable_kinds = field\ndotnet_naming_symbols.private_internal_fields.applicable_accessibilities = private, internal\n\ndotnet_naming_style.camel_case_underscore_style.required_prefix = _\ndotnet_naming_style.camel_case_underscore_style.capitalization = camel_case\n\n# Code style defaults\ndotnet_sort_system_directives_first = true\ncsharp_preserve_single_line_blocks = true\ncsharp_preserve_single_line_statements = false\n\n# Expression-level preferences\ndotnet_style_object_initializer = true:suggestion\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_explicit_tuple_names = true:suggestion\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_null_propagation = true:suggestion\n\n# Expression-bodied members\ncsharp_style_expression_bodied_methods = false:none\ncsharp_style_expression_bodied_constructors = false:none\ncsharp_style_expression_bodied_operators = false:none\ncsharp_style_expression_bodied_properties = true:none\ncsharp_style_expression_bodied_indexers = true:none\ncsharp_style_expression_bodied_accessors = true:none\n\n# Pattern matching\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\ncsharp_style_inlined_variable_declaration = true:suggestion\n\n# Null checking preferences\ncsharp_style_throw_expression = true:suggestion\ncsharp_style_conditional_delegate_call = true:suggestion\n\n# Space preferences\ncsharp_space_after_cast = false\ncsharp_space_after_colon_in_inheritance_clause = true\ncsharp_space_after_comma = true\ncsharp_space_after_dot = false\ncsharp_space_after_keywords_in_control_flow_statements = true\ncsharp_space_after_semicolon_in_for_statement = true\ncsharp_space_around_binary_operators = before_and_after\ncsharp_space_around_declaration_statements = do_not_ignore\ncsharp_space_before_colon_in_inheritance_clause = true\ncsharp_space_before_comma = false\ncsharp_space_before_dot = false\ncsharp_space_before_open_square_brackets = false\ncsharp_space_before_semicolon_in_for_statement = false\ncsharp_space_between_empty_square_brackets = false\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\ncsharp_space_between_method_call_name_and_opening_parenthesis = false\ncsharp_space_between_method_call_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_name_and_open_parenthesis = false\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\ncsharp_space_between_parentheses = false\ncsharp_space_between_square_brackets = false\n\n[*.{asm,inc}]\nindent_size = 8\n\n# Xml project files\n[*.{csproj,vcxproj,vcxproj.filters,proj,nativeproj,locproj}]\nindent_size = 2\n\n# Xml config files\n[*.{props,targets,config,nuspec}]\nindent_size = 2\n\n[CMakeLists.txt]\nindent_size = 2\n\n[*.cmd]\nindent_size = 2\n\n")),(0,r.yg)("h2",{id:"comments"},"Comments"),(0,r.yg)("b",null,"Avoid positional markers"),(0,r.yg)("p",null,"They usually just add noise. Let the functions and variable names along with the proper indentation and formatting give the visual structure to your code."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"////////////////////////////////////////////////////////////////////////////////\n// Scope Model Instantiation\n////////////////////////////////////////////////////////////////////////////////\nvar model = new[]\n{\n    menu: 'foo',\n    nav: 'bar'\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Action setup\n////////////////////////////////////////////////////////////////////////////////\nvoid Actions()\n{\n    // ...\n};\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"\n#region Scope Model Instantiation\n\nvar model = {\n    menu: 'foo',\n    nav: 'bar'\n};\n\n#endregion\n\n#region Action setup\n\nvoid Actions() {\n    // ...\n};\n\n#endregion\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var model = new[]\n{\n    menu: 'foo',\n    nav: 'bar'\n};\n\nvoid Actions()\n{\n    // ...\n};\n")),(0,r.yg)("b",null,"Don't leave commented out code in your codebase"),(0,r.yg)("p",null,"Version control exists for a reason. Leave old code in your history."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"doStuff();\n// doOtherStuff();\n// doSomeMoreStuff();\n// doSoMuchStuff();\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"doStuff();\n")),(0,r.yg)("b",null,"Don't have journal comments"),(0,r.yg)("p",null,"Remember, use version control! There's no need for dead code, commented code, and especially journal comments. Use ",(0,r.yg)("inlineCode",{parentName:"p"},"git log")," to get history!"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"/**\n * 2018-12-20: Removed monads, didn't understand them (RM)\n * 2017-10-01: Improved using special monads (JP)\n * 2016-02-03: Removed type-checking (LI)\n * 2015-03-14: Added combine with type-checking (JR)\n */\npublic int Combine(int a,int b)\n{\n    return a + b;\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public int Combine(int a,int b)\n{\n    return a + b;\n}\n")),(0,r.yg)("b",null,"Only comment things that have business logic complexity"),(0,r.yg)("p",null,"Comments are an apology, not a requirement. Good code ",(0,r.yg)("em",{parentName:"p"},"mostly")," documents itself."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public int HashIt(string data)\n{\n    // The hash\n    var hash = 0;\n\n    // Length of string\n    var length = data.length;\n\n    // Loop through every character in data\n    for (var i = 0; i < length; i++)\n    {\n        // Get character code.\n        const char = data.charCodeAt(i);\n        // Make the hash\n        hash = ((hash << 5) - hash) + char;\n        // Convert to 32-bit integer\n        hash &= hash;\n    }\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Better but still Bad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public int HashIt(string data)\n{\n    var hash = 0;\n    var length = data.length;\n    for (var i = 0; i < length; i++)\n    {\n        const char = data.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n\n        // Convert to 32-bit integer\n        hash &= hash;\n    }\n}\n")),(0,r.yg)("p",null,"If a comment explains WHAT the code is doing, it is probably a useless comment and can be implemented with a well named variable or function. The comment in the previous code could be replaced with a function named ",(0,r.yg)("inlineCode",{parentName:"p"},"ConvertTo32bitInt")," so this comment is still useless.\nHowever it would be hard to express by code WHY the developer chose djb2 hash algorithm instead of sha-1 or another hash function. In that case a comment is acceptable."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Good:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public int Hash(string data)\n{\n    var hash = 0;\n    var length = data.length;\n\n    for (var i = 0; i < length; i++)\n    {\n        var character = data[i];\n        // use of djb2 hash algorithm as it has a good compromise\n        // between speed and low collision with a very simple implementation\n        hash = ((hash << 5) - hash) + character;\n\n        hash = ConvertTo32BitInt(hash);\n    }\n    return hash;\n}\n\nprivate int ConvertTo32BitInt(int value)\n{\n    return value & value;\n}\n")))}u.isMDXComponent=!0}}]);